// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package db

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AttachmentType string

const (
	AttachmentTypeImage    AttachmentType = "image"
	AttachmentTypeVideo    AttachmentType = "video"
	AttachmentTypeGif      AttachmentType = "gif"
	AttachmentTypeDocument AttachmentType = "document"
)

func (e *AttachmentType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AttachmentType(s)
	case string:
		*e = AttachmentType(s)
	default:
		return fmt.Errorf("unsupported scan type for AttachmentType: %T", src)
	}
	return nil
}

type NullAttachmentType struct {
	AttachmentType AttachmentType `json:"attachment_type"`
	Valid          bool           `json:"valid"` // Valid is true if AttachmentType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAttachmentType) Scan(value interface{}) error {
	if value == nil {
		ns.AttachmentType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AttachmentType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAttachmentType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AttachmentType), nil
}

func (e AttachmentType) Valid() bool {
	switch e {
	case AttachmentTypeImage,
		AttachmentTypeVideo,
		AttachmentTypeGif,
		AttachmentTypeDocument:
		return true
	}
	return false
}

func AllAttachmentTypeValues() []AttachmentType {
	return []AttachmentType{
		AttachmentTypeImage,
		AttachmentTypeVideo,
		AttachmentTypeGif,
		AttachmentTypeDocument,
	}
}

type EventType string

const (
	EventTypeImpression EventType = "impression"
	EventTypeClick      EventType = "click"
	EventTypeLike       EventType = "like"
	EventTypeShare      EventType = "share"
	EventTypeComment    EventType = "comment"
	EventTypeRetweet    EventType = "retweet"
	EventTypeReply      EventType = "reply"
	EventTypeView       EventType = "view"
	EventTypeSave       EventType = "save"
)

func (e *EventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventType(s)
	case string:
		*e = EventType(s)
	default:
		return fmt.Errorf("unsupported scan type for EventType: %T", src)
	}
	return nil
}

type NullEventType struct {
	EventType EventType `json:"event_type"`
	Valid     bool      `json:"valid"` // Valid is true if EventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventType) Scan(value interface{}) error {
	if value == nil {
		ns.EventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventType), nil
}

func (e EventType) Valid() bool {
	switch e {
	case EventTypeImpression,
		EventTypeClick,
		EventTypeLike,
		EventTypeShare,
		EventTypeComment,
		EventTypeRetweet,
		EventTypeReply,
		EventTypeView,
		EventTypeSave:
		return true
	}
	return false
}

func AllEventTypeValues() []EventType {
	return []EventType{
		EventTypeImpression,
		EventTypeClick,
		EventTypeLike,
		EventTypeShare,
		EventTypeComment,
		EventTypeRetweet,
		EventTypeReply,
		EventTypeView,
		EventTypeSave,
	}
}

type InvoiceStatus string

const (
	InvoiceStatusDraft         InvoiceStatus = "draft"
	InvoiceStatusOpen          InvoiceStatus = "open"
	InvoiceStatusPaid          InvoiceStatus = "paid"
	InvoiceStatusVoid          InvoiceStatus = "void"
	InvoiceStatusUncollectible InvoiceStatus = "uncollectible"
)

func (e *InvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoiceStatus(s)
	case string:
		*e = InvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoiceStatus: %T", src)
	}
	return nil
}

type NullInvoiceStatus struct {
	InvoiceStatus InvoiceStatus `json:"invoice_status"`
	Valid         bool          `json:"valid"` // Valid is true if InvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoiceStatus), nil
}

func (e InvoiceStatus) Valid() bool {
	switch e {
	case InvoiceStatusDraft,
		InvoiceStatusOpen,
		InvoiceStatusPaid,
		InvoiceStatusVoid,
		InvoiceStatusUncollectible:
		return true
	}
	return false
}

func AllInvoiceStatusValues() []InvoiceStatus {
	return []InvoiceStatus{
		InvoiceStatusDraft,
		InvoiceStatusOpen,
		InvoiceStatusPaid,
		InvoiceStatusVoid,
		InvoiceStatusUncollectible,
	}
}

type JobStatus string

const (
	JobStatusPending   JobStatus = "pending"
	JobStatusRunning   JobStatus = "running"
	JobStatusCompleted JobStatus = "completed"
	JobStatusFailed    JobStatus = "failed"
)

func (e *JobStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobStatus(s)
	case string:
		*e = JobStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobStatus: %T", src)
	}
	return nil
}

type NullJobStatus struct {
	JobStatus JobStatus `json:"job_status"`
	Valid     bool      `json:"valid"` // Valid is true if JobStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobStatus), nil
}

func (e JobStatus) Valid() bool {
	switch e {
	case JobStatusPending,
		JobStatusRunning,
		JobStatusCompleted,
		JobStatusFailed:
		return true
	}
	return false
}

func AllJobStatusValues() []JobStatus {
	return []JobStatus{
		JobStatusPending,
		JobStatusRunning,
		JobStatusCompleted,
		JobStatusFailed,
	}
}

type PlanInterval string

const (
	PlanIntervalMonth PlanInterval = "month"
	PlanIntervalYear  PlanInterval = "year"
)

func (e *PlanInterval) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PlanInterval(s)
	case string:
		*e = PlanInterval(s)
	default:
		return fmt.Errorf("unsupported scan type for PlanInterval: %T", src)
	}
	return nil
}

type NullPlanInterval struct {
	PlanInterval PlanInterval `json:"plan_interval"`
	Valid        bool         `json:"valid"` // Valid is true if PlanInterval is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlanInterval) Scan(value interface{}) error {
	if value == nil {
		ns.PlanInterval, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PlanInterval.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlanInterval) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PlanInterval), nil
}

func (e PlanInterval) Valid() bool {
	switch e {
	case PlanIntervalMonth,
		PlanIntervalYear:
		return true
	}
	return false
}

func AllPlanIntervalValues() []PlanInterval {
	return []PlanInterval{
		PlanIntervalMonth,
		PlanIntervalYear,
	}
}

type PostStatus string

const (
	PostStatusDraft      PostStatus = "draft"
	PostStatusScheduled  PostStatus = "scheduled"
	PostStatusQueued     PostStatus = "queued"
	PostStatusProcessing PostStatus = "processing"
	PostStatusPublished  PostStatus = "published"
	PostStatusFailed     PostStatus = "failed"
	PostStatusCancelled  PostStatus = "cancelled"
)

func (e *PostStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PostStatus(s)
	case string:
		*e = PostStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PostStatus: %T", src)
	}
	return nil
}

type NullPostStatus struct {
	PostStatus PostStatus `json:"post_status"`
	Valid      bool       `json:"valid"` // Valid is true if PostStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPostStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PostStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PostStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPostStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PostStatus), nil
}

func (e PostStatus) Valid() bool {
	switch e {
	case PostStatusDraft,
		PostStatusScheduled,
		PostStatusQueued,
		PostStatusProcessing,
		PostStatusPublished,
		PostStatusFailed,
		PostStatusCancelled:
		return true
	}
	return false
}

func AllPostStatusValues() []PostStatus {
	return []PostStatus{
		PostStatusDraft,
		PostStatusScheduled,
		PostStatusQueued,
		PostStatusProcessing,
		PostStatusPublished,
		PostStatusFailed,
		PostStatusCancelled,
	}
}

type QueueStatus string

const (
	QueueStatusPending    QueueStatus = "pending"
	QueueStatusProcessing QueueStatus = "processing"
	QueueStatusCompleted  QueueStatus = "completed"
	QueueStatusFailed     QueueStatus = "failed"
)

func (e *QueueStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = QueueStatus(s)
	case string:
		*e = QueueStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for QueueStatus: %T", src)
	}
	return nil
}

type NullQueueStatus struct {
	QueueStatus QueueStatus `json:"queue_status"`
	Valid       bool        `json:"valid"` // Valid is true if QueueStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullQueueStatus) Scan(value interface{}) error {
	if value == nil {
		ns.QueueStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.QueueStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullQueueStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.QueueStatus), nil
}

func (e QueueStatus) Valid() bool {
	switch e {
	case QueueStatusPending,
		QueueStatusProcessing,
		QueueStatusCompleted,
		QueueStatusFailed:
		return true
	}
	return false
}

func AllQueueStatusValues() []QueueStatus {
	return []QueueStatus{
		QueueStatusPending,
		QueueStatusProcessing,
		QueueStatusCompleted,
		QueueStatusFailed,
	}
}

type SocialAccountStatus string

const (
	SocialAccountStatusActive  SocialAccountStatus = "active"
	SocialAccountStatusExpired SocialAccountStatus = "expired"
	SocialAccountStatusRevoked SocialAccountStatus = "revoked"
	SocialAccountStatusError   SocialAccountStatus = "error"
)

func (e *SocialAccountStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SocialAccountStatus(s)
	case string:
		*e = SocialAccountStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SocialAccountStatus: %T", src)
	}
	return nil
}

type NullSocialAccountStatus struct {
	SocialAccountStatus SocialAccountStatus `json:"social_account_status"`
	Valid               bool                `json:"valid"` // Valid is true if SocialAccountStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSocialAccountStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SocialAccountStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SocialAccountStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSocialAccountStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SocialAccountStatus), nil
}

func (e SocialAccountStatus) Valid() bool {
	switch e {
	case SocialAccountStatusActive,
		SocialAccountStatusExpired,
		SocialAccountStatusRevoked,
		SocialAccountStatusError:
		return true
	}
	return false
}

func AllSocialAccountStatusValues() []SocialAccountStatus {
	return []SocialAccountStatus{
		SocialAccountStatusActive,
		SocialAccountStatusExpired,
		SocialAccountStatusRevoked,
		SocialAccountStatusError,
	}
}

type SocialPlatform string

const (
	SocialPlatformTwitter   SocialPlatform = "twitter"
	SocialPlatformFacebook  SocialPlatform = "facebook"
	SocialPlatformInstagram SocialPlatform = "instagram"
	SocialPlatformLinkedin  SocialPlatform = "linkedin"
	SocialPlatformTiktok    SocialPlatform = "tiktok"
	SocialPlatformYoutube   SocialPlatform = "youtube"
	SocialPlatformPinterest SocialPlatform = "pinterest"
	SocialPlatformThreads   SocialPlatform = "threads"
)

func (e *SocialPlatform) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SocialPlatform(s)
	case string:
		*e = SocialPlatform(s)
	default:
		return fmt.Errorf("unsupported scan type for SocialPlatform: %T", src)
	}
	return nil
}

type NullSocialPlatform struct {
	SocialPlatform SocialPlatform `json:"social_platform"`
	Valid          bool           `json:"valid"` // Valid is true if SocialPlatform is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSocialPlatform) Scan(value interface{}) error {
	if value == nil {
		ns.SocialPlatform, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SocialPlatform.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSocialPlatform) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SocialPlatform), nil
}

func (e SocialPlatform) Valid() bool {
	switch e {
	case SocialPlatformTwitter,
		SocialPlatformFacebook,
		SocialPlatformInstagram,
		SocialPlatformLinkedin,
		SocialPlatformTiktok,
		SocialPlatformYoutube,
		SocialPlatformPinterest,
		SocialPlatformThreads:
		return true
	}
	return false
}

func AllSocialPlatformValues() []SocialPlatform {
	return []SocialPlatform{
		SocialPlatformTwitter,
		SocialPlatformFacebook,
		SocialPlatformInstagram,
		SocialPlatformLinkedin,
		SocialPlatformTiktok,
		SocialPlatformYoutube,
		SocialPlatformPinterest,
		SocialPlatformThreads,
	}
}

type SubscriptionStatus string

const (
	SubscriptionStatusActive   SubscriptionStatus = "active"
	SubscriptionStatusTrialing SubscriptionStatus = "trialing"
	SubscriptionStatusPastDue  SubscriptionStatus = "past_due"
	SubscriptionStatusCanceled SubscriptionStatus = "canceled"
	SubscriptionStatusUnpaid   SubscriptionStatus = "unpaid"
)

func (e *SubscriptionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubscriptionStatus(s)
	case string:
		*e = SubscriptionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SubscriptionStatus: %T", src)
	}
	return nil
}

type NullSubscriptionStatus struct {
	SubscriptionStatus SubscriptionStatus `json:"subscription_status"`
	Valid              bool               `json:"valid"` // Valid is true if SubscriptionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubscriptionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SubscriptionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubscriptionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubscriptionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubscriptionStatus), nil
}

func (e SubscriptionStatus) Valid() bool {
	switch e {
	case SubscriptionStatusActive,
		SubscriptionStatusTrialing,
		SubscriptionStatusPastDue,
		SubscriptionStatusCanceled,
		SubscriptionStatusUnpaid:
		return true
	}
	return false
}

func AllSubscriptionStatusValues() []SubscriptionStatus {
	return []SubscriptionStatus{
		SubscriptionStatusActive,
		SubscriptionStatusTrialing,
		SubscriptionStatusPastDue,
		SubscriptionStatusCanceled,
		SubscriptionStatusUnpaid,
	}
}

type WebhookSource string

const (
	WebhookSourceStripe         WebhookSource = "stripe"
	WebhookSourceSocialPlatform WebhookSource = "social_platform"
	WebhookSourceInternal       WebhookSource = "internal"
)

func (e *WebhookSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WebhookSource(s)
	case string:
		*e = WebhookSource(s)
	default:
		return fmt.Errorf("unsupported scan type for WebhookSource: %T", src)
	}
	return nil
}

type NullWebhookSource struct {
	WebhookSource WebhookSource `json:"webhook_source"`
	Valid         bool          `json:"valid"` // Valid is true if WebhookSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWebhookSource) Scan(value interface{}) error {
	if value == nil {
		ns.WebhookSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WebhookSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWebhookSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WebhookSource), nil
}

func (e WebhookSource) Valid() bool {
	switch e {
	case WebhookSourceStripe,
		WebhookSourceSocialPlatform,
		WebhookSourceInternal:
		return true
	}
	return false
}

func AllWebhookSourceValues() []WebhookSource {
	return []WebhookSource{
		WebhookSourceStripe,
		WebhookSourceSocialPlatform,
		WebhookSourceInternal,
	}
}

// Social media engagement events
type AnalyticsEvent struct {
	ID            uuid.UUID          `db:"id" json:"id"`
	PostID        uuid.UUID          `db:"post_id" json:"post_id"`
	EventType     EventType          `db:"event_type" json:"event_type"`
	EventValue    *int32             `db:"event_value" json:"event_value"`
	EventMetadata []byte             `db:"event_metadata" json:"event_metadata"`
	RecordedAt    pgtype.Timestamptz `db:"recorded_at" json:"recorded_at"`
}

// Billing invoices
type Invoice struct {
	ID               uuid.UUID          `db:"id" json:"id"`
	SubscriptionID   uuid.UUID          `db:"subscription_id" json:"subscription_id"`
	StripeInvoiceID  string             `db:"stripe_invoice_id" json:"stripe_invoice_id"`
	AmountDue        pgtype.Numeric     `db:"amount_due" json:"amount_due"`
	AmountPaid       pgtype.Numeric     `db:"amount_paid" json:"amount_paid"`
	Currency         *string            `db:"currency" json:"currency"`
	Status           NullInvoiceStatus  `db:"status" json:"status"`
	InvoicePdf       *string            `db:"invoice_pdf" json:"invoice_pdf"`
	HostedInvoiceUrl *string            `db:"hosted_invoice_url" json:"hosted_invoice_url"`
	DueDate          pgtype.Timestamptz `db:"due_date" json:"due_date"`
	PaidAt           pgtype.Timestamptz `db:"paid_at" json:"paid_at"`
	CreatedAt        pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Background job execution log
type JobRun struct {
	ID          uuid.UUID          `db:"id" json:"id"`
	JobName     string             `db:"job_name" json:"job_name"`
	Status      NullJobStatus      `db:"status" json:"status"`
	Payload     []byte             `db:"payload" json:"payload"`
	Result      []byte             `db:"result" json:"result"`
	Error       *string            `db:"error" json:"error"`
	StartedAt   pgtype.Timestamptz `db:"started_at" json:"started_at"`
	CompletedAt pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Subscription plans
type Plan struct {
	ID                   uuid.UUID          `db:"id" json:"id"`
	Name                 string             `db:"name" json:"name"`
	Slug                 string             `db:"slug" json:"slug"`
	Description          *string            `db:"description" json:"description"`
	PriceMonthly         pgtype.Numeric     `db:"price_monthly" json:"price_monthly"`
	PriceYearly          pgtype.Numeric     `db:"price_yearly" json:"price_yearly"`
	Features             []byte             `db:"features" json:"features"`
	Limits               []byte             `db:"limits" json:"limits"`
	IsActive             *bool              `db:"is_active" json:"is_active"`
	StripePriceIDMonthly *string            `db:"stripe_price_id_monthly" json:"stripe_price_id_monthly"`
	StripePriceIDYearly  *string            `db:"stripe_price_id_yearly" json:"stripe_price_id_yearly"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Archive of published posts
type Post struct {
	ID                 uuid.UUID          `db:"id" json:"id"`
	ScheduledPostID    pgtype.UUID        `db:"scheduled_post_id" json:"scheduled_post_id"`
	TeamID             uuid.UUID          `db:"team_id" json:"team_id"`
	SocialAccountID    uuid.UUID          `db:"social_account_id" json:"social_account_id"`
	PlatformPostID     *string            `db:"platform_post_id" json:"platform_post_id"`
	PlatformPostUrl    *string            `db:"platform_post_url" json:"platform_post_url"`
	Content            string             `db:"content" json:"content"`
	PublishedAt        pgtype.Timestamptz `db:"published_at" json:"published_at"`
	Metrics            []byte             `db:"metrics" json:"metrics"`
	LastMetricsFetchAt pgtype.Timestamptz `db:"last_metrics_fetch_at" json:"last_metrics_fetch_at"`
	CreatedAt          pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Media attachments for posts
type PostAttachment struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	ScheduledPostID uuid.UUID          `db:"scheduled_post_id" json:"scheduled_post_id"`
	Type            AttachmentType     `db:"type" json:"type"`
	Url             string             `db:"url" json:"url"`
	ThumbnailUrl    *string            `db:"thumbnail_url" json:"thumbnail_url"`
	FileSize        *int64             `db:"file_size" json:"file_size"`
	MimeType        *string            `db:"mime_type" json:"mime_type"`
	Width           *int32             `db:"width" json:"width"`
	Height          *int32             `db:"height" json:"height"`
	Duration        *int32             `db:"duration" json:"duration"`
	AltText         *string            `db:"alt_text" json:"alt_text"`
	UploadOrder     *int32             `db:"upload_order" json:"upload_order"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

// Background job queue for post publishing
type PostQueue struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	ScheduledPostID uuid.UUID          `db:"scheduled_post_id" json:"scheduled_post_id"`
	Status          NullQueueStatus    `db:"status" json:"status"`
	Priority        *int32             `db:"priority" json:"priority"`
	Attempts        *int32             `db:"attempts" json:"attempts"`
	MaxAttempts     *int32             `db:"max_attempts" json:"max_attempts"`
	Error           *string            `db:"error" json:"error"`
	ScheduledFor    time.Time          `db:"scheduled_for" json:"scheduled_for"`
	StartedAt       pgtype.Timestamptz `db:"started_at" json:"started_at"`
	CompletedAt     pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// JWT refresh tokens for session management
type RefreshToken struct {
	ID        uuid.UUID          `db:"id" json:"id"`
	UserID    uuid.UUID          `db:"user_id" json:"user_id"`
	TokenHash string             `db:"token_hash" json:"token_hash"`
	ExpiresAt time.Time          `db:"expires_at" json:"expires_at"`
	Revoked   *bool              `db:"revoked" json:"revoked"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

// Role-based access control
type Role struct {
	ID          uuid.UUID          `db:"id" json:"id"`
	Name        string             `db:"name" json:"name"`
	Description *string            `db:"description" json:"description"`
	Permissions []byte             `db:"permissions" json:"permissions"`
	IsSystem    *bool              `db:"is_system" json:"is_system"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Posts scheduled for future publishing
type ScheduledPost struct {
	ID                      uuid.UUID          `db:"id" json:"id"`
	TeamID                  uuid.UUID          `db:"team_id" json:"team_id"`
	CreatedBy               uuid.UUID          `db:"created_by" json:"created_by"`
	SocialAccountID         uuid.UUID          `db:"social_account_id" json:"social_account_id"`
	Content                 string             `db:"content" json:"content"`
	ContentHtml             *string            `db:"content_html" json:"content_html"`
	ShortenedLinks          []byte             `db:"shortened_links" json:"shortened_links"`
	Status                  NullPostStatus     `db:"status" json:"status"`
	ScheduledAt             pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	PublishedAt             pgtype.Timestamptz `db:"published_at" json:"published_at"`
	PlatformSpecificOptions []byte             `db:"platform_specific_options" json:"platform_specific_options"`
	ErrorMessage            *string            `db:"error_message" json:"error_message"`
	RetryCount              *int32             `db:"retry_count" json:"retry_count"`
	MaxRetries              *int32             `db:"max_retries" json:"max_retries"`
	CreatedAt               pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt               pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

// Connected social media accounts
type SocialAccount struct {
	ID             uuid.UUID               `db:"id" json:"id"`
	TeamID         uuid.UUID               `db:"team_id" json:"team_id"`
	Platform       SocialPlatform          `db:"platform" json:"platform"`
	PlatformUserID string                  `db:"platform_user_id" json:"platform_user_id"`
	Username       *string                 `db:"username" json:"username"`
	DisplayName    *string                 `db:"display_name" json:"display_name"`
	AvatarUrl      *string                 `db:"avatar_url" json:"avatar_url"`
	ProfileUrl     *string                 `db:"profile_url" json:"profile_url"`
	AccountType    *string                 `db:"account_type" json:"account_type"`
	Status         NullSocialAccountStatus `db:"status" json:"status"`
	Metadata       []byte                  `db:"metadata" json:"metadata"`
	ConnectedBy    pgtype.UUID             `db:"connected_by" json:"connected_by"`
	ConnectedAt    pgtype.Timestamptz      `db:"connected_at" json:"connected_at"`
	LastSyncedAt   pgtype.Timestamptz      `db:"last_synced_at" json:"last_synced_at"`
	CreatedAt      pgtype.Timestamptz      `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamptz      `db:"updated_at" json:"updated_at"`
	DeletedAt      pgtype.Timestamptz      `db:"deleted_at" json:"deleted_at"`
}

// OAuth tokens for social platforms (encrypted)
type SocialToken struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	SocialAccountID uuid.UUID          `db:"social_account_id" json:"social_account_id"`
	AccessToken     string             `db:"access_token" json:"access_token"`
	RefreshToken    *string            `db:"refresh_token" json:"refresh_token"`
	TokenType       *string            `db:"token_type" json:"token_type"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	Scope           *string            `db:"scope" json:"scope"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Team subscriptions
type Subscription struct {
	ID                   uuid.UUID              `db:"id" json:"id"`
	TeamID               uuid.UUID              `db:"team_id" json:"team_id"`
	PlanID               uuid.UUID              `db:"plan_id" json:"plan_id"`
	Status               NullSubscriptionStatus `db:"status" json:"status"`
	Interval             PlanInterval           `db:"interval" json:"interval"`
	StripeSubscriptionID *string                `db:"stripe_subscription_id" json:"stripe_subscription_id"`
	StripeCustomerID     *string                `db:"stripe_customer_id" json:"stripe_customer_id"`
	CurrentPeriodStart   pgtype.Timestamptz     `db:"current_period_start" json:"current_period_start"`
	CurrentPeriodEnd     pgtype.Timestamptz     `db:"current_period_end" json:"current_period_end"`
	CancelAtPeriodEnd    *bool                  `db:"cancel_at_period_end" json:"cancel_at_period_end"`
	CanceledAt           pgtype.Timestamptz     `db:"canceled_at" json:"canceled_at"`
	TrialStart           pgtype.Timestamptz     `db:"trial_start" json:"trial_start"`
	TrialEnd             pgtype.Timestamptz     `db:"trial_end" json:"trial_end"`
	CreatedAt            pgtype.Timestamptz     `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz     `db:"updated_at" json:"updated_at"`
}

// Organizations/teams for multi-tenancy
type Team struct {
	ID        uuid.UUID          `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	Slug      string             `db:"slug" json:"slug"`
	AvatarUrl *string            `db:"avatar_url" json:"avatar_url"`
	Settings  []byte             `db:"settings" json:"settings"`
	IsActive  *bool              `db:"is_active" json:"is_active"`
	CreatedBy pgtype.UUID        `db:"created_by" json:"created_by"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

// User membership in teams with roles
type TeamMembership struct {
	ID                   uuid.UUID          `db:"id" json:"id"`
	TeamID               uuid.UUID          `db:"team_id" json:"team_id"`
	UserID               uuid.UUID          `db:"user_id" json:"user_id"`
	RoleID               uuid.UUID          `db:"role_id" json:"role_id"`
	InvitedBy            pgtype.UUID        `db:"invited_by" json:"invited_by"`
	InvitationToken      *string            `db:"invitation_token" json:"invitation_token"`
	InvitationAcceptedAt pgtype.Timestamptz `db:"invitation_accepted_at" json:"invitation_accepted_at"`
	IsActive             *bool              `db:"is_active" json:"is_active"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt            pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

// User accounts with authentication
type User struct {
	ID            uuid.UUID          `db:"id" json:"id"`
	Email         string             `db:"email" json:"email"`
	EmailVerified *bool              `db:"email_verified" json:"email_verified"`
	PasswordHash  *string            `db:"password_hash" json:"password_hash"`
	FullName      *string            `db:"full_name" json:"full_name"`
	AvatarUrl     *string            `db:"avatar_url" json:"avatar_url"`
	Timezone      *string            `db:"timezone" json:"timezone"`
	Locale        *string            `db:"locale" json:"locale"`
	IsActive      *bool              `db:"is_active" json:"is_active"`
	LastLoginAt   pgtype.Timestamptz `db:"last_login_at" json:"last_login_at"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt     pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

// Webhook event log
type WebhooksLog struct {
	ID          uuid.UUID          `db:"id" json:"id"`
	Source      WebhookSource      `db:"source" json:"source"`
	EventType   string             `db:"event_type" json:"event_type"`
	Payload     json.RawMessage    `db:"payload" json:"payload"`
	Processed   *bool              `db:"processed" json:"processed"`
	ProcessedAt pgtype.Timestamptz `db:"processed_at" json:"processed_at"`
	Error       *string            `db:"error" json:"error"`
	ReceivedAt  pgtype.Timestamptz `db:"received_at" json:"received_at"`
}
