// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: social_accounts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const GetSocialAccountByID = `-- name: GetSocialAccountByID :one
SELECT id, team_id, platform, platform_user_id, username, display_name, avatar_url, profile_url, account_type, status, metadata, connected_by, connected_at, last_synced_at, created_at, updated_at, deleted_at FROM social_accounts
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetSocialAccountByID(ctx context.Context, id uuid.UUID) (SocialAccount, error) {
	row := q.db.QueryRow(ctx, GetSocialAccountByID, id)
	var i SocialAccount
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Platform,
		&i.PlatformUserID,
		&i.Username,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.ProfileUrl,
		&i.AccountType,
		&i.Status,
		&i.Metadata,
		&i.ConnectedBy,
		&i.ConnectedAt,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const GetSocialAccountWithToken = `-- name: GetSocialAccountWithToken :one
SELECT 
    sa.id, sa.team_id, sa.platform, sa.platform_user_id, sa.username, sa.display_name, sa.avatar_url, sa.profile_url, sa.account_type, sa.status, sa.metadata, sa.connected_by, sa.connected_at, sa.last_synced_at, sa.created_at, sa.updated_at, sa.deleted_at,
    st.access_token,
    st.refresh_token,
    st.expires_at as token_expires_at
FROM social_accounts sa
LEFT JOIN social_tokens st ON sa.id = st.social_account_id
WHERE sa.id = $1 AND sa.deleted_at IS NULL
`

type GetSocialAccountWithTokenRow struct {
	ID             uuid.UUID               `db:"id" json:"id"`
	TeamID         uuid.UUID               `db:"team_id" json:"team_id"`
	Platform       SocialPlatform          `db:"platform" json:"platform"`
	PlatformUserID string                  `db:"platform_user_id" json:"platform_user_id"`
	Username       *string                 `db:"username" json:"username"`
	DisplayName    *string                 `db:"display_name" json:"display_name"`
	AvatarUrl      *string                 `db:"avatar_url" json:"avatar_url"`
	ProfileUrl     *string                 `db:"profile_url" json:"profile_url"`
	AccountType    *string                 `db:"account_type" json:"account_type"`
	Status         NullSocialAccountStatus `db:"status" json:"status"`
	Metadata       []byte                  `db:"metadata" json:"metadata"`
	ConnectedBy    pgtype.UUID             `db:"connected_by" json:"connected_by"`
	ConnectedAt    pgtype.Timestamptz      `db:"connected_at" json:"connected_at"`
	LastSyncedAt   pgtype.Timestamptz      `db:"last_synced_at" json:"last_synced_at"`
	CreatedAt      pgtype.Timestamptz      `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamptz      `db:"updated_at" json:"updated_at"`
	DeletedAt      pgtype.Timestamptz      `db:"deleted_at" json:"deleted_at"`
	AccessToken    *string                 `db:"access_token" json:"access_token"`
	RefreshToken   *string                 `db:"refresh_token" json:"refresh_token"`
	TokenExpiresAt pgtype.Timestamptz      `db:"token_expires_at" json:"token_expires_at"`
}

func (q *Queries) GetSocialAccountWithToken(ctx context.Context, id uuid.UUID) (GetSocialAccountWithTokenRow, error) {
	row := q.db.QueryRow(ctx, GetSocialAccountWithToken, id)
	var i GetSocialAccountWithTokenRow
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Platform,
		&i.PlatformUserID,
		&i.Username,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.ProfileUrl,
		&i.AccountType,
		&i.Status,
		&i.Metadata,
		&i.ConnectedBy,
		&i.ConnectedAt,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
	)
	return i, err
}

const LinkSocialAccount = `-- name: LinkSocialAccount :one

INSERT INTO social_accounts (
    team_id,
    platform,
    platform_user_id,
    username,
    display_name,
    avatar_url,
    profile_url,
    account_type,
    status,
    metadata,
    connected_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, team_id, platform, platform_user_id, username, display_name, avatar_url, profile_url, account_type, status, metadata, connected_by, connected_at, last_synced_at, created_at, updated_at, deleted_at
`

type LinkSocialAccountParams struct {
	TeamID         uuid.UUID               `db:"team_id" json:"team_id"`
	Platform       SocialPlatform          `db:"platform" json:"platform"`
	PlatformUserID string                  `db:"platform_user_id" json:"platform_user_id"`
	Username       *string                 `db:"username" json:"username"`
	DisplayName    *string                 `db:"display_name" json:"display_name"`
	AvatarUrl      *string                 `db:"avatar_url" json:"avatar_url"`
	ProfileUrl     *string                 `db:"profile_url" json:"profile_url"`
	AccountType    *string                 `db:"account_type" json:"account_type"`
	Status         NullSocialAccountStatus `db:"status" json:"status"`
	Metadata       []byte                  `db:"metadata" json:"metadata"`
	ConnectedBy    pgtype.UUID             `db:"connected_by" json:"connected_by"`
}

// path: backend/sql/social_accounts.sql
func (q *Queries) LinkSocialAccount(ctx context.Context, arg LinkSocialAccountParams) (SocialAccount, error) {
	row := q.db.QueryRow(ctx, LinkSocialAccount,
		arg.TeamID,
		arg.Platform,
		arg.PlatformUserID,
		arg.Username,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.ProfileUrl,
		arg.AccountType,
		arg.Status,
		arg.Metadata,
		arg.ConnectedBy,
	)
	var i SocialAccount
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Platform,
		&i.PlatformUserID,
		&i.Username,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.ProfileUrl,
		&i.AccountType,
		&i.Status,
		&i.Metadata,
		&i.ConnectedBy,
		&i.ConnectedAt,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const ListSocialAccountsByPlatform = `-- name: ListSocialAccountsByPlatform :many
SELECT id, team_id, platform, platform_user_id, username, display_name, avatar_url, profile_url, account_type, status, metadata, connected_by, connected_at, last_synced_at, created_at, updated_at, deleted_at FROM social_accounts
WHERE team_id = $1 
  AND platform = $2 
  AND deleted_at IS NULL
ORDER BY created_at ASC
`

type ListSocialAccountsByPlatformParams struct {
	TeamID   uuid.UUID      `db:"team_id" json:"team_id"`
	Platform SocialPlatform `db:"platform" json:"platform"`
}

func (q *Queries) ListSocialAccountsByPlatform(ctx context.Context, arg ListSocialAccountsByPlatformParams) ([]SocialAccount, error) {
	rows, err := q.db.Query(ctx, ListSocialAccountsByPlatform, arg.TeamID, arg.Platform)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SocialAccount{}
	for rows.Next() {
		var i SocialAccount
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.Platform,
			&i.PlatformUserID,
			&i.Username,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.ProfileUrl,
			&i.AccountType,
			&i.Status,
			&i.Metadata,
			&i.ConnectedBy,
			&i.ConnectedAt,
			&i.LastSyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSocialAccountsByTeam = `-- name: ListSocialAccountsByTeam :many
SELECT id, team_id, platform, platform_user_id, username, display_name, avatar_url, profile_url, account_type, status, metadata, connected_by, connected_at, last_synced_at, created_at, updated_at, deleted_at FROM social_accounts
WHERE team_id = $1 AND deleted_at IS NULL
ORDER BY platform ASC, created_at ASC
`

func (q *Queries) ListSocialAccountsByTeam(ctx context.Context, teamID uuid.UUID) ([]SocialAccount, error) {
	rows, err := q.db.Query(ctx, ListSocialAccountsByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SocialAccount{}
	for rows.Next() {
		var i SocialAccount
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.Platform,
			&i.PlatformUserID,
			&i.Username,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.ProfileUrl,
			&i.AccountType,
			&i.Status,
			&i.Metadata,
			&i.ConnectedBy,
			&i.ConnectedAt,
			&i.LastSyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SoftDeleteSocialAccount = `-- name: SoftDeleteSocialAccount :exec
UPDATE social_accounts
SET 
    deleted_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteSocialAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, SoftDeleteSocialAccount, id)
	return err
}

const UpdateSocialAccountMetadata = `-- name: UpdateSocialAccountMetadata :exec
UPDATE social_accounts
SET 
    username = COALESCE($1, username),
    display_name = COALESCE($2, display_name),
    avatar_url = COALESCE($3, avatar_url),
    metadata = COALESCE($4, metadata),
    last_synced_at = NOW(),
    updated_at = NOW()
WHERE id = $5
`

type UpdateSocialAccountMetadataParams struct {
	Username    *string   `db:"username" json:"username"`
	DisplayName *string   `db:"display_name" json:"display_name"`
	AvatarUrl   *string   `db:"avatar_url" json:"avatar_url"`
	Metadata    []byte    `db:"metadata" json:"metadata"`
	ID          uuid.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateSocialAccountMetadata(ctx context.Context, arg UpdateSocialAccountMetadataParams) error {
	_, err := q.db.Exec(ctx, UpdateSocialAccountMetadata,
		arg.Username,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.Metadata,
		arg.ID,
	)
	return err
}

const UpdateSocialAccountStatus = `-- name: UpdateSocialAccountStatus :exec
UPDATE social_accounts
SET 
    status = $2,
    metadata = COALESCE($3, metadata),
    updated_at = NOW()
WHERE id = $1
`

type UpdateSocialAccountStatusParams struct {
	ID       uuid.UUID               `db:"id" json:"id"`
	Status   NullSocialAccountStatus `db:"status" json:"status"`
	Metadata []byte                  `db:"metadata" json:"metadata"`
}

func (q *Queries) UpdateSocialAccountStatus(ctx context.Context, arg UpdateSocialAccountStatusParams) error {
	_, err := q.db.Exec(ctx, UpdateSocialAccountStatus, arg.ID, arg.Status, arg.Metadata)
	return err
}
