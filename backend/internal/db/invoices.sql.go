// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: invoices.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CountUnpaidInvoices = `-- name: CountUnpaidInvoices :one
SELECT COUNT(*)
FROM invoices i
INNER JOIN subscriptions s ON i.subscription_id = s.id
WHERE s.team_id = $1
  AND i.status IN ('open', 'past_due')
`

func (q *Queries) CountUnpaidInvoices(ctx context.Context, teamID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountUnpaidInvoices, teamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateInvoice = `-- name: CreateInvoice :one

INSERT INTO invoices (
    subscription_id,
    stripe_invoice_id,
    amount_due,
    amount_paid,
    currency,
    status,
    due_date,
    paid_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, subscription_id, stripe_invoice_id, amount_due, amount_paid, currency, status, invoice_pdf, hosted_invoice_url, due_date, paid_at, created_at, updated_at
`

type CreateInvoiceParams struct {
	SubscriptionID  uuid.UUID          `db:"subscription_id" json:"subscription_id"`
	StripeInvoiceID string             `db:"stripe_invoice_id" json:"stripe_invoice_id"`
	AmountDue       pgtype.Numeric     `db:"amount_due" json:"amount_due"`
	AmountPaid      pgtype.Numeric     `db:"amount_paid" json:"amount_paid"`
	Currency        *string            `db:"currency" json:"currency"`
	Status          NullInvoiceStatus  `db:"status" json:"status"`
	DueDate         pgtype.Timestamptz `db:"due_date" json:"due_date"`
	PaidAt          pgtype.Timestamptz `db:"paid_at" json:"paid_at"`
}

// path: backend/sql/invoices.sql
// ðŸ”„ REFACTORED - Use due_date, paid_at (no invoice_date, no invoice_pdf_url)
func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, CreateInvoice,
		arg.SubscriptionID,
		arg.StripeInvoiceID,
		arg.AmountDue,
		arg.AmountPaid,
		arg.Currency,
		arg.Status,
		arg.DueDate,
		arg.PaidAt,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.StripeInvoiceID,
		&i.AmountDue,
		&i.AmountPaid,
		&i.Currency,
		&i.Status,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetInvoiceByID = `-- name: GetInvoiceByID :one
SELECT id, subscription_id, stripe_invoice_id, amount_due, amount_paid, currency, status, invoice_pdf, hosted_invoice_url, due_date, paid_at, created_at, updated_at FROM invoices WHERE id = $1
`

func (q *Queries) GetInvoiceByID(ctx context.Context, id uuid.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, GetInvoiceByID, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.StripeInvoiceID,
		&i.AmountDue,
		&i.AmountPaid,
		&i.Currency,
		&i.Status,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetInvoiceByStripeID = `-- name: GetInvoiceByStripeID :one
SELECT id, subscription_id, stripe_invoice_id, amount_due, amount_paid, currency, status, invoice_pdf, hosted_invoice_url, due_date, paid_at, created_at, updated_at FROM invoices WHERE stripe_invoice_id = $1
`

func (q *Queries) GetInvoiceByStripeID(ctx context.Context, stripeInvoiceID string) (Invoice, error) {
	row := q.db.QueryRow(ctx, GetInvoiceByStripeID, stripeInvoiceID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.StripeInvoiceID,
		&i.AmountDue,
		&i.AmountPaid,
		&i.Currency,
		&i.Status,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ListInvoicesBySubscription = `-- name: ListInvoicesBySubscription :many
SELECT id, subscription_id, stripe_invoice_id, amount_due, amount_paid, currency, status, invoice_pdf, hosted_invoice_url, due_date, paid_at, created_at, updated_at FROM invoices
WHERE subscription_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListInvoicesBySubscription(ctx context.Context, subscriptionID uuid.UUID) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, ListInvoicesBySubscription, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.StripeInvoiceID,
			&i.AmountDue,
			&i.AmountPaid,
			&i.Currency,
			&i.Status,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListInvoicesByTeam = `-- name: ListInvoicesByTeam :many
SELECT i.id, i.subscription_id, i.stripe_invoice_id, i.amount_due, i.amount_paid, i.currency, i.status, i.invoice_pdf, i.hosted_invoice_url, i.due_date, i.paid_at, i.created_at, i.updated_at
FROM invoices i
INNER JOIN subscriptions s ON i.subscription_id = s.id
WHERE s.team_id = $1
ORDER BY i.created_at DESC
LIMIT $2 OFFSET $3
`

type ListInvoicesByTeamParams struct {
	TeamID uuid.UUID `db:"team_id" json:"team_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListInvoicesByTeam(ctx context.Context, arg ListInvoicesByTeamParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, ListInvoicesByTeam, arg.TeamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.StripeInvoiceID,
			&i.AmountDue,
			&i.AmountPaid,
			&i.Currency,
			&i.Status,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateInvoiceStatus = `-- name: UpdateInvoiceStatus :exec
UPDATE invoices
SET 
    status = $2,
    amount_paid = COALESCE($3, amount_paid),
    paid_at = COALESCE($4, paid_at),
    updated_at = NOW()
WHERE id = $1
`

type UpdateInvoiceStatusParams struct {
	ID         uuid.UUID          `db:"id" json:"id"`
	Status     NullInvoiceStatus  `db:"status" json:"status"`
	AmountPaid pgtype.Numeric     `db:"amount_paid" json:"amount_paid"`
	PaidAt     pgtype.Timestamptz `db:"paid_at" json:"paid_at"`
}

func (q *Queries) UpdateInvoiceStatus(ctx context.Context, arg UpdateInvoiceStatusParams) error {
	_, err := q.db.Exec(ctx, UpdateInvoiceStatus,
		arg.ID,
		arg.Status,
		arg.AmountPaid,
		arg.PaidAt,
	)
	return err
}
