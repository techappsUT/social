// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package db

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

type AttachmentType string

const (
	AttachmentTypeImage    AttachmentType = "image"
	AttachmentTypeVideo    AttachmentType = "video"
	AttachmentTypeGif      AttachmentType = "gif"
	AttachmentTypeDocument AttachmentType = "document"
)

func (e *AttachmentType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AttachmentType(s)
	case string:
		*e = AttachmentType(s)
	default:
		return fmt.Errorf("unsupported scan type for AttachmentType: %T", src)
	}
	return nil
}

type NullAttachmentType struct {
	AttachmentType AttachmentType `json:"attachment_type"`
	Valid          bool           `json:"valid"` // Valid is true if AttachmentType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAttachmentType) Scan(value interface{}) error {
	if value == nil {
		ns.AttachmentType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AttachmentType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAttachmentType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AttachmentType), nil
}

func (e AttachmentType) Valid() bool {
	switch e {
	case AttachmentTypeImage,
		AttachmentTypeVideo,
		AttachmentTypeGif,
		AttachmentTypeDocument:
		return true
	}
	return false
}

func AllAttachmentTypeValues() []AttachmentType {
	return []AttachmentType{
		AttachmentTypeImage,
		AttachmentTypeVideo,
		AttachmentTypeGif,
		AttachmentTypeDocument,
	}
}

type EventType string

const (
	EventTypeImpression EventType = "impression"
	EventTypeClick      EventType = "click"
	EventTypeLike       EventType = "like"
	EventTypeShare      EventType = "share"
	EventTypeComment    EventType = "comment"
	EventTypeRetweet    EventType = "retweet"
	EventTypeReply      EventType = "reply"
	EventTypeView       EventType = "view"
	EventTypeSave       EventType = "save"
)

func (e *EventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventType(s)
	case string:
		*e = EventType(s)
	default:
		return fmt.Errorf("unsupported scan type for EventType: %T", src)
	}
	return nil
}

type NullEventType struct {
	EventType EventType `json:"event_type"`
	Valid     bool      `json:"valid"` // Valid is true if EventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventType) Scan(value interface{}) error {
	if value == nil {
		ns.EventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventType), nil
}

func (e EventType) Valid() bool {
	switch e {
	case EventTypeImpression,
		EventTypeClick,
		EventTypeLike,
		EventTypeShare,
		EventTypeComment,
		EventTypeRetweet,
		EventTypeReply,
		EventTypeView,
		EventTypeSave:
		return true
	}
	return false
}

func AllEventTypeValues() []EventType {
	return []EventType{
		EventTypeImpression,
		EventTypeClick,
		EventTypeLike,
		EventTypeShare,
		EventTypeComment,
		EventTypeRetweet,
		EventTypeReply,
		EventTypeView,
		EventTypeSave,
	}
}

type InvoiceStatus string

const (
	InvoiceStatusDraft         InvoiceStatus = "draft"
	InvoiceStatusOpen          InvoiceStatus = "open"
	InvoiceStatusPaid          InvoiceStatus = "paid"
	InvoiceStatusVoid          InvoiceStatus = "void"
	InvoiceStatusUncollectible InvoiceStatus = "uncollectible"
)

func (e *InvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoiceStatus(s)
	case string:
		*e = InvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoiceStatus: %T", src)
	}
	return nil
}

type NullInvoiceStatus struct {
	InvoiceStatus InvoiceStatus `json:"invoice_status"`
	Valid         bool          `json:"valid"` // Valid is true if InvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoiceStatus), nil
}

func (e InvoiceStatus) Valid() bool {
	switch e {
	case InvoiceStatusDraft,
		InvoiceStatusOpen,
		InvoiceStatusPaid,
		InvoiceStatusVoid,
		InvoiceStatusUncollectible:
		return true
	}
	return false
}

func AllInvoiceStatusValues() []InvoiceStatus {
	return []InvoiceStatus{
		InvoiceStatusDraft,
		InvoiceStatusOpen,
		InvoiceStatusPaid,
		InvoiceStatusVoid,
		InvoiceStatusUncollectible,
	}
}

type JobStatus string

const (
	JobStatusPending   JobStatus = "pending"
	JobStatusRunning   JobStatus = "running"
	JobStatusCompleted JobStatus = "completed"
	JobStatusFailed    JobStatus = "failed"
)

func (e *JobStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobStatus(s)
	case string:
		*e = JobStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobStatus: %T", src)
	}
	return nil
}

type NullJobStatus struct {
	JobStatus JobStatus `json:"job_status"`
	Valid     bool      `json:"valid"` // Valid is true if JobStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobStatus), nil
}

func (e JobStatus) Valid() bool {
	switch e {
	case JobStatusPending,
		JobStatusRunning,
		JobStatusCompleted,
		JobStatusFailed:
		return true
	}
	return false
}

func AllJobStatusValues() []JobStatus {
	return []JobStatus{
		JobStatusPending,
		JobStatusRunning,
		JobStatusCompleted,
		JobStatusFailed,
	}
}

type PlanInterval string

const (
	PlanIntervalMonth PlanInterval = "month"
	PlanIntervalYear  PlanInterval = "year"
)

func (e *PlanInterval) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PlanInterval(s)
	case string:
		*e = PlanInterval(s)
	default:
		return fmt.Errorf("unsupported scan type for PlanInterval: %T", src)
	}
	return nil
}

type NullPlanInterval struct {
	PlanInterval PlanInterval `json:"plan_interval"`
	Valid        bool         `json:"valid"` // Valid is true if PlanInterval is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlanInterval) Scan(value interface{}) error {
	if value == nil {
		ns.PlanInterval, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PlanInterval.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlanInterval) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PlanInterval), nil
}

func (e PlanInterval) Valid() bool {
	switch e {
	case PlanIntervalMonth,
		PlanIntervalYear:
		return true
	}
	return false
}

func AllPlanIntervalValues() []PlanInterval {
	return []PlanInterval{
		PlanIntervalMonth,
		PlanIntervalYear,
	}
}

type PostStatus string

const (
	PostStatusDraft      PostStatus = "draft"
	PostStatusScheduled  PostStatus = "scheduled"
	PostStatusQueued     PostStatus = "queued"
	PostStatusProcessing PostStatus = "processing"
	PostStatusPublished  PostStatus = "published"
	PostStatusFailed     PostStatus = "failed"
	PostStatusCancelled  PostStatus = "cancelled"
)

func (e *PostStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PostStatus(s)
	case string:
		*e = PostStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PostStatus: %T", src)
	}
	return nil
}

type NullPostStatus struct {
	PostStatus PostStatus `json:"post_status"`
	Valid      bool       `json:"valid"` // Valid is true if PostStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPostStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PostStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PostStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPostStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PostStatus), nil
}

func (e PostStatus) Valid() bool {
	switch e {
	case PostStatusDraft,
		PostStatusScheduled,
		PostStatusQueued,
		PostStatusProcessing,
		PostStatusPublished,
		PostStatusFailed,
		PostStatusCancelled:
		return true
	}
	return false
}

func AllPostStatusValues() []PostStatus {
	return []PostStatus{
		PostStatusDraft,
		PostStatusScheduled,
		PostStatusQueued,
		PostStatusProcessing,
		PostStatusPublished,
		PostStatusFailed,
		PostStatusCancelled,
	}
}

type QueueStatus string

const (
	QueueStatusPending    QueueStatus = "pending"
	QueueStatusProcessing QueueStatus = "processing"
	QueueStatusCompleted  QueueStatus = "completed"
	QueueStatusFailed     QueueStatus = "failed"
)

func (e *QueueStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = QueueStatus(s)
	case string:
		*e = QueueStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for QueueStatus: %T", src)
	}
	return nil
}

type NullQueueStatus struct {
	QueueStatus QueueStatus `json:"queue_status"`
	Valid       bool        `json:"valid"` // Valid is true if QueueStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullQueueStatus) Scan(value interface{}) error {
	if value == nil {
		ns.QueueStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.QueueStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullQueueStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.QueueStatus), nil
}

func (e QueueStatus) Valid() bool {
	switch e {
	case QueueStatusPending,
		QueueStatusProcessing,
		QueueStatusCompleted,
		QueueStatusFailed:
		return true
	}
	return false
}

func AllQueueStatusValues() []QueueStatus {
	return []QueueStatus{
		QueueStatusPending,
		QueueStatusProcessing,
		QueueStatusCompleted,
		QueueStatusFailed,
	}
}

type SocialAccountStatus string

const (
	SocialAccountStatusActive  SocialAccountStatus = "active"
	SocialAccountStatusExpired SocialAccountStatus = "expired"
	SocialAccountStatusRevoked SocialAccountStatus = "revoked"
	SocialAccountStatusError   SocialAccountStatus = "error"
)

func (e *SocialAccountStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SocialAccountStatus(s)
	case string:
		*e = SocialAccountStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SocialAccountStatus: %T", src)
	}
	return nil
}

type NullSocialAccountStatus struct {
	SocialAccountStatus SocialAccountStatus `json:"social_account_status"`
	Valid               bool                `json:"valid"` // Valid is true if SocialAccountStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSocialAccountStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SocialAccountStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SocialAccountStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSocialAccountStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SocialAccountStatus), nil
}

func (e SocialAccountStatus) Valid() bool {
	switch e {
	case SocialAccountStatusActive,
		SocialAccountStatusExpired,
		SocialAccountStatusRevoked,
		SocialAccountStatusError:
		return true
	}
	return false
}

func AllSocialAccountStatusValues() []SocialAccountStatus {
	return []SocialAccountStatus{
		SocialAccountStatusActive,
		SocialAccountStatusExpired,
		SocialAccountStatusRevoked,
		SocialAccountStatusError,
	}
}

type SocialPlatform string

const (
	SocialPlatformTwitter   SocialPlatform = "twitter"
	SocialPlatformFacebook  SocialPlatform = "facebook"
	SocialPlatformInstagram SocialPlatform = "instagram"
	SocialPlatformLinkedin  SocialPlatform = "linkedin"
	SocialPlatformTiktok    SocialPlatform = "tiktok"
	SocialPlatformYoutube   SocialPlatform = "youtube"
	SocialPlatformPinterest SocialPlatform = "pinterest"
	SocialPlatformThreads   SocialPlatform = "threads"
)

func (e *SocialPlatform) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SocialPlatform(s)
	case string:
		*e = SocialPlatform(s)
	default:
		return fmt.Errorf("unsupported scan type for SocialPlatform: %T", src)
	}
	return nil
}

type NullSocialPlatform struct {
	SocialPlatform SocialPlatform `json:"social_platform"`
	Valid          bool           `json:"valid"` // Valid is true if SocialPlatform is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSocialPlatform) Scan(value interface{}) error {
	if value == nil {
		ns.SocialPlatform, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SocialPlatform.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSocialPlatform) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SocialPlatform), nil
}

func (e SocialPlatform) Valid() bool {
	switch e {
	case SocialPlatformTwitter,
		SocialPlatformFacebook,
		SocialPlatformInstagram,
		SocialPlatformLinkedin,
		SocialPlatformTiktok,
		SocialPlatformYoutube,
		SocialPlatformPinterest,
		SocialPlatformThreads:
		return true
	}
	return false
}

func AllSocialPlatformValues() []SocialPlatform {
	return []SocialPlatform{
		SocialPlatformTwitter,
		SocialPlatformFacebook,
		SocialPlatformInstagram,
		SocialPlatformLinkedin,
		SocialPlatformTiktok,
		SocialPlatformYoutube,
		SocialPlatformPinterest,
		SocialPlatformThreads,
	}
}

type SubscriptionStatus string

const (
	SubscriptionStatusActive   SubscriptionStatus = "active"
	SubscriptionStatusTrialing SubscriptionStatus = "trialing"
	SubscriptionStatusPastDue  SubscriptionStatus = "past_due"
	SubscriptionStatusCanceled SubscriptionStatus = "canceled"
	SubscriptionStatusUnpaid   SubscriptionStatus = "unpaid"
)

func (e *SubscriptionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubscriptionStatus(s)
	case string:
		*e = SubscriptionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SubscriptionStatus: %T", src)
	}
	return nil
}

type NullSubscriptionStatus struct {
	SubscriptionStatus SubscriptionStatus `json:"subscription_status"`
	Valid              bool               `json:"valid"` // Valid is true if SubscriptionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubscriptionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SubscriptionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubscriptionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubscriptionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubscriptionStatus), nil
}

func (e SubscriptionStatus) Valid() bool {
	switch e {
	case SubscriptionStatusActive,
		SubscriptionStatusTrialing,
		SubscriptionStatusPastDue,
		SubscriptionStatusCanceled,
		SubscriptionStatusUnpaid:
		return true
	}
	return false
}

func AllSubscriptionStatusValues() []SubscriptionStatus {
	return []SubscriptionStatus{
		SubscriptionStatusActive,
		SubscriptionStatusTrialing,
		SubscriptionStatusPastDue,
		SubscriptionStatusCanceled,
		SubscriptionStatusUnpaid,
	}
}

type WebhookSource string

const (
	WebhookSourceStripe         WebhookSource = "stripe"
	WebhookSourceSocialPlatform WebhookSource = "social_platform"
	WebhookSourceInternal       WebhookSource = "internal"
)

func (e *WebhookSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WebhookSource(s)
	case string:
		*e = WebhookSource(s)
	default:
		return fmt.Errorf("unsupported scan type for WebhookSource: %T", src)
	}
	return nil
}

type NullWebhookSource struct {
	WebhookSource WebhookSource `json:"webhook_source"`
	Valid         bool          `json:"valid"` // Valid is true if WebhookSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWebhookSource) Scan(value interface{}) error {
	if value == nil {
		ns.WebhookSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WebhookSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWebhookSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WebhookSource), nil
}

func (e WebhookSource) Valid() bool {
	switch e {
	case WebhookSourceStripe,
		WebhookSourceSocialPlatform,
		WebhookSourceInternal:
		return true
	}
	return false
}

func AllWebhookSourceValues() []WebhookSource {
	return []WebhookSource{
		WebhookSourceStripe,
		WebhookSourceSocialPlatform,
		WebhookSourceInternal,
	}
}

// Social media engagement events
type AnalyticsEvent struct {
	ID            uuid.UUID             `db:"id" json:"id"`
	PostID        uuid.UUID             `db:"post_id" json:"post_id"`
	EventType     EventType             `db:"event_type" json:"event_type"`
	EventValue    sql.NullInt32         `db:"event_value" json:"event_value"`
	EventMetadata pqtype.NullRawMessage `db:"event_metadata" json:"event_metadata"`
	RecordedAt    sql.NullTime          `db:"recorded_at" json:"recorded_at"`
}

// Billing invoices
type Invoice struct {
	ID               uuid.UUID         `db:"id" json:"id"`
	SubscriptionID   uuid.UUID         `db:"subscription_id" json:"subscription_id"`
	StripeInvoiceID  string            `db:"stripe_invoice_id" json:"stripe_invoice_id"`
	AmountDue        string            `db:"amount_due" json:"amount_due"`
	AmountPaid       sql.NullString    `db:"amount_paid" json:"amount_paid"`
	Currency         sql.NullString    `db:"currency" json:"currency"`
	Status           NullInvoiceStatus `db:"status" json:"status"`
	InvoicePdf       sql.NullString    `db:"invoice_pdf" json:"invoice_pdf"`
	HostedInvoiceUrl sql.NullString    `db:"hosted_invoice_url" json:"hosted_invoice_url"`
	DueDate          sql.NullTime      `db:"due_date" json:"due_date"`
	PaidAt           sql.NullTime      `db:"paid_at" json:"paid_at"`
	CreatedAt        sql.NullTime      `db:"created_at" json:"created_at"`
	UpdatedAt        sql.NullTime      `db:"updated_at" json:"updated_at"`
}

// Background job execution log
type JobRun struct {
	ID          uuid.UUID             `db:"id" json:"id"`
	JobName     string                `db:"job_name" json:"job_name"`
	Status      NullJobStatus         `db:"status" json:"status"`
	Payload     pqtype.NullRawMessage `db:"payload" json:"payload"`
	Result      pqtype.NullRawMessage `db:"result" json:"result"`
	Error       sql.NullString        `db:"error" json:"error"`
	StartedAt   sql.NullTime          `db:"started_at" json:"started_at"`
	CompletedAt sql.NullTime          `db:"completed_at" json:"completed_at"`
	CreatedAt   sql.NullTime          `db:"created_at" json:"created_at"`
	UpdatedAt   sql.NullTime          `db:"updated_at" json:"updated_at"`
}

// Subscription plans
type Plan struct {
	ID                   uuid.UUID             `db:"id" json:"id"`
	Name                 string                `db:"name" json:"name"`
	Slug                 string                `db:"slug" json:"slug"`
	Description          sql.NullString        `db:"description" json:"description"`
	PriceMonthly         string                `db:"price_monthly" json:"price_monthly"`
	PriceYearly          string                `db:"price_yearly" json:"price_yearly"`
	Features             pqtype.NullRawMessage `db:"features" json:"features"`
	Limits               pqtype.NullRawMessage `db:"limits" json:"limits"`
	IsActive             sql.NullBool          `db:"is_active" json:"is_active"`
	StripePriceIDMonthly sql.NullString        `db:"stripe_price_id_monthly" json:"stripe_price_id_monthly"`
	StripePriceIDYearly  sql.NullString        `db:"stripe_price_id_yearly" json:"stripe_price_id_yearly"`
	CreatedAt            sql.NullTime          `db:"created_at" json:"created_at"`
	UpdatedAt            sql.NullTime          `db:"updated_at" json:"updated_at"`
}

// Archive of published posts
type Post struct {
	ID                 uuid.UUID             `db:"id" json:"id"`
	ScheduledPostID    uuid.NullUUID         `db:"scheduled_post_id" json:"scheduled_post_id"`
	TeamID             uuid.UUID             `db:"team_id" json:"team_id"`
	SocialAccountID    uuid.UUID             `db:"social_account_id" json:"social_account_id"`
	PlatformPostID     sql.NullString        `db:"platform_post_id" json:"platform_post_id"`
	PlatformPostUrl    sql.NullString        `db:"platform_post_url" json:"platform_post_url"`
	Content            string                `db:"content" json:"content"`
	PublishedAt        sql.NullTime          `db:"published_at" json:"published_at"`
	Metrics            pqtype.NullRawMessage `db:"metrics" json:"metrics"`
	LastMetricsFetchAt sql.NullTime          `db:"last_metrics_fetch_at" json:"last_metrics_fetch_at"`
	CreatedAt          sql.NullTime          `db:"created_at" json:"created_at"`
	UpdatedAt          sql.NullTime          `db:"updated_at" json:"updated_at"`
}

// Media attachments for posts
type PostAttachment struct {
	ID              uuid.UUID      `db:"id" json:"id"`
	ScheduledPostID uuid.UUID      `db:"scheduled_post_id" json:"scheduled_post_id"`
	Type            AttachmentType `db:"type" json:"type"`
	Url             string         `db:"url" json:"url"`
	ThumbnailUrl    sql.NullString `db:"thumbnail_url" json:"thumbnail_url"`
	FileSize        sql.NullInt64  `db:"file_size" json:"file_size"`
	MimeType        sql.NullString `db:"mime_type" json:"mime_type"`
	Width           sql.NullInt32  `db:"width" json:"width"`
	Height          sql.NullInt32  `db:"height" json:"height"`
	Duration        sql.NullInt32  `db:"duration" json:"duration"`
	AltText         sql.NullString `db:"alt_text" json:"alt_text"`
	UploadOrder     sql.NullInt32  `db:"upload_order" json:"upload_order"`
	CreatedAt       sql.NullTime   `db:"created_at" json:"created_at"`
}

// Background job queue for post publishing
type PostQueue struct {
	ID              uuid.UUID       `db:"id" json:"id"`
	ScheduledPostID uuid.UUID       `db:"scheduled_post_id" json:"scheduled_post_id"`
	Status          NullQueueStatus `db:"status" json:"status"`
	Priority        sql.NullInt32   `db:"priority" json:"priority"`
	Attempts        sql.NullInt32   `db:"attempts" json:"attempts"`
	MaxAttempts     sql.NullInt32   `db:"max_attempts" json:"max_attempts"`
	Error           sql.NullString  `db:"error" json:"error"`
	ScheduledFor    time.Time       `db:"scheduled_for" json:"scheduled_for"`
	StartedAt       sql.NullTime    `db:"started_at" json:"started_at"`
	CompletedAt     sql.NullTime    `db:"completed_at" json:"completed_at"`
	CreatedAt       sql.NullTime    `db:"created_at" json:"created_at"`
	UpdatedAt       sql.NullTime    `db:"updated_at" json:"updated_at"`
}

// JWT refresh tokens for session management
type RefreshToken struct {
	ID        uuid.UUID    `db:"id" json:"id"`
	UserID    uuid.UUID    `db:"user_id" json:"user_id"`
	TokenHash string       `db:"token_hash" json:"token_hash"`
	ExpiresAt time.Time    `db:"expires_at" json:"expires_at"`
	Revoked   sql.NullBool `db:"revoked" json:"revoked"`
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
}

// Role-based access control
type Role struct {
	ID          uuid.UUID             `db:"id" json:"id"`
	Name        string                `db:"name" json:"name"`
	Description sql.NullString        `db:"description" json:"description"`
	Permissions pqtype.NullRawMessage `db:"permissions" json:"permissions"`
	IsSystem    sql.NullBool          `db:"is_system" json:"is_system"`
	CreatedAt   sql.NullTime          `db:"created_at" json:"created_at"`
	UpdatedAt   sql.NullTime          `db:"updated_at" json:"updated_at"`
}

// Posts scheduled for future publishing
type ScheduledPost struct {
	ID                      uuid.UUID             `db:"id" json:"id"`
	TeamID                  uuid.UUID             `db:"team_id" json:"team_id"`
	CreatedBy               uuid.UUID             `db:"created_by" json:"created_by"`
	SocialAccountID         uuid.UUID             `db:"social_account_id" json:"social_account_id"`
	Content                 string                `db:"content" json:"content"`
	ContentHtml             sql.NullString        `db:"content_html" json:"content_html"`
	ShortenedLinks          pqtype.NullRawMessage `db:"shortened_links" json:"shortened_links"`
	Status                  NullPostStatus        `db:"status" json:"status"`
	ScheduledAt             sql.NullTime          `db:"scheduled_at" json:"scheduled_at"`
	PublishedAt             sql.NullTime          `db:"published_at" json:"published_at"`
	PlatformSpecificOptions pqtype.NullRawMessage `db:"platform_specific_options" json:"platform_specific_options"`
	ErrorMessage            sql.NullString        `db:"error_message" json:"error_message"`
	RetryCount              sql.NullInt32         `db:"retry_count" json:"retry_count"`
	MaxRetries              sql.NullInt32         `db:"max_retries" json:"max_retries"`
	CreatedAt               sql.NullTime          `db:"created_at" json:"created_at"`
	UpdatedAt               sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt               sql.NullTime          `db:"deleted_at" json:"deleted_at"`
}

// Connected social media accounts
type SocialAccount struct {
	ID             uuid.UUID               `db:"id" json:"id"`
	TeamID         uuid.UUID               `db:"team_id" json:"team_id"`
	Platform       SocialPlatform          `db:"platform" json:"platform"`
	PlatformUserID string                  `db:"platform_user_id" json:"platform_user_id"`
	Username       sql.NullString          `db:"username" json:"username"`
	DisplayName    sql.NullString          `db:"display_name" json:"display_name"`
	AvatarUrl      sql.NullString          `db:"avatar_url" json:"avatar_url"`
	ProfileUrl     sql.NullString          `db:"profile_url" json:"profile_url"`
	AccountType    sql.NullString          `db:"account_type" json:"account_type"`
	Status         NullSocialAccountStatus `db:"status" json:"status"`
	Metadata       pqtype.NullRawMessage   `db:"metadata" json:"metadata"`
	ConnectedBy    uuid.NullUUID           `db:"connected_by" json:"connected_by"`
	ConnectedAt    sql.NullTime            `db:"connected_at" json:"connected_at"`
	LastSyncedAt   sql.NullTime            `db:"last_synced_at" json:"last_synced_at"`
	CreatedAt      sql.NullTime            `db:"created_at" json:"created_at"`
	UpdatedAt      sql.NullTime            `db:"updated_at" json:"updated_at"`
	DeletedAt      sql.NullTime            `db:"deleted_at" json:"deleted_at"`
}

// OAuth tokens for social platforms (encrypted)
type SocialToken struct {
	ID              uuid.UUID      `db:"id" json:"id"`
	SocialAccountID uuid.UUID      `db:"social_account_id" json:"social_account_id"`
	AccessToken     string         `db:"access_token" json:"access_token"`
	RefreshToken    sql.NullString `db:"refresh_token" json:"refresh_token"`
	TokenType       sql.NullString `db:"token_type" json:"token_type"`
	ExpiresAt       sql.NullTime   `db:"expires_at" json:"expires_at"`
	Scope           sql.NullString `db:"scope" json:"scope"`
	CreatedAt       sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt       sql.NullTime   `db:"updated_at" json:"updated_at"`
}

// Team subscriptions
type Subscription struct {
	ID                   uuid.UUID              `db:"id" json:"id"`
	TeamID               uuid.UUID              `db:"team_id" json:"team_id"`
	PlanID               uuid.UUID              `db:"plan_id" json:"plan_id"`
	Status               NullSubscriptionStatus `db:"status" json:"status"`
	Interval             PlanInterval           `db:"interval" json:"interval"`
	StripeSubscriptionID sql.NullString         `db:"stripe_subscription_id" json:"stripe_subscription_id"`
	StripeCustomerID     sql.NullString         `db:"stripe_customer_id" json:"stripe_customer_id"`
	CurrentPeriodStart   sql.NullTime           `db:"current_period_start" json:"current_period_start"`
	CurrentPeriodEnd     sql.NullTime           `db:"current_period_end" json:"current_period_end"`
	CancelAtPeriodEnd    sql.NullBool           `db:"cancel_at_period_end" json:"cancel_at_period_end"`
	CanceledAt           sql.NullTime           `db:"canceled_at" json:"canceled_at"`
	TrialStart           sql.NullTime           `db:"trial_start" json:"trial_start"`
	TrialEnd             sql.NullTime           `db:"trial_end" json:"trial_end"`
	CreatedAt            sql.NullTime           `db:"created_at" json:"created_at"`
	UpdatedAt            sql.NullTime           `db:"updated_at" json:"updated_at"`
}

// Organizations/teams for multi-tenancy
type Team struct {
	ID        uuid.UUID             `db:"id" json:"id"`
	Name      string                `db:"name" json:"name"`
	Slug      string                `db:"slug" json:"slug"`
	AvatarUrl sql.NullString        `db:"avatar_url" json:"avatar_url"`
	Settings  pqtype.NullRawMessage `db:"settings" json:"settings"`
	IsActive  sql.NullBool          `db:"is_active" json:"is_active"`
	CreatedBy uuid.NullUUID         `db:"created_by" json:"created_by"`
	CreatedAt sql.NullTime          `db:"created_at" json:"created_at"`
	UpdatedAt sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt sql.NullTime          `db:"deleted_at" json:"deleted_at"`
}

// User membership in teams with roles
type TeamMembership struct {
	ID                   uuid.UUID      `db:"id" json:"id"`
	TeamID               uuid.UUID      `db:"team_id" json:"team_id"`
	UserID               uuid.UUID      `db:"user_id" json:"user_id"`
	RoleID               uuid.UUID      `db:"role_id" json:"role_id"`
	InvitedBy            uuid.NullUUID  `db:"invited_by" json:"invited_by"`
	InvitationToken      sql.NullString `db:"invitation_token" json:"invitation_token"`
	InvitationAcceptedAt sql.NullTime   `db:"invitation_accepted_at" json:"invitation_accepted_at"`
	IsActive             sql.NullBool   `db:"is_active" json:"is_active"`
	CreatedAt            sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt            sql.NullTime   `db:"updated_at" json:"updated_at"`
	DeletedAt            sql.NullTime   `db:"deleted_at" json:"deleted_at"`
}

// User accounts with authentication
type User struct {
	ID            uuid.UUID      `db:"id" json:"id"`
	Email         string         `db:"email" json:"email"`
	EmailVerified sql.NullBool   `db:"email_verified" json:"email_verified"`
	PasswordHash  sql.NullString `db:"password_hash" json:"password_hash"`
	FullName      sql.NullString `db:"full_name" json:"full_name"`
	AvatarUrl     sql.NullString `db:"avatar_url" json:"avatar_url"`
	Timezone      sql.NullString `db:"timezone" json:"timezone"`
	Locale        sql.NullString `db:"locale" json:"locale"`
	IsActive      sql.NullBool   `db:"is_active" json:"is_active"`
	LastLoginAt   sql.NullTime   `db:"last_login_at" json:"last_login_at"`
	CreatedAt     sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt     sql.NullTime   `db:"updated_at" json:"updated_at"`
	DeletedAt     sql.NullTime   `db:"deleted_at" json:"deleted_at"`
}

// Webhook event log
type WebhooksLog struct {
	ID          uuid.UUID       `db:"id" json:"id"`
	Source      WebhookSource   `db:"source" json:"source"`
	EventType   string          `db:"event_type" json:"event_type"`
	Payload     json.RawMessage `db:"payload" json:"payload"`
	Processed   sql.NullBool    `db:"processed" json:"processed"`
	ProcessedAt sql.NullTime    `db:"processed_at" json:"processed_at"`
	Error       sql.NullString  `db:"error" json:"error"`
	ReceivedAt  sql.NullTime    `db:"received_at" json:"received_at"`
}
