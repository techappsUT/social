// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: post_queue.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const CompleteQueueItem = `-- name: CompleteQueueItem :exec
UPDATE post_queue SET 
    status = 'completed',
    completed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) CompleteQueueItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, CompleteQueueItem, id)
	return err
}

const EnqueuePost = `-- name: EnqueuePost :one

INSERT INTO post_queue (
    scheduled_post_id,
    status,
    priority,
    scheduled_for,
    max_attempts
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, scheduled_post_id, status, priority, scheduled_for, attempt_count, max_attempts, last_error, worker_id, locked_at, lock_expires_at, completed_at, created_at, updated_at
`

type EnqueuePostParams struct {
	ScheduledPostID uuid.UUID       `db:"scheduled_post_id" json:"scheduled_post_id"`
	Status          NullQueueStatus `db:"status" json:"status"`
	Priority        *int32          `db:"priority" json:"priority"`
	ScheduledFor    time.Time       `db:"scheduled_for" json:"scheduled_for"`
	MaxAttempts     *int32          `db:"max_attempts" json:"max_attempts"`
}

// path: backend/sql/post_queue.sql
func (q *Queries) EnqueuePost(ctx context.Context, arg EnqueuePostParams) (PostQueue, error) {
	row := q.db.QueryRow(ctx, EnqueuePost,
		arg.ScheduledPostID,
		arg.Status,
		arg.Priority,
		arg.ScheduledFor,
		arg.MaxAttempts,
	)
	var i PostQueue
	err := row.Scan(
		&i.ID,
		&i.ScheduledPostID,
		&i.Status,
		&i.Priority,
		&i.ScheduledFor,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.LastError,
		&i.WorkerID,
		&i.LockedAt,
		&i.LockExpiresAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const FailQueueItem = `-- name: FailQueueItem :exec
UPDATE post_queue SET 
    status = CASE 
        WHEN attempt_count + 1 >= max_attempts THEN 'failed'::queue_status
        ELSE 'retrying'::queue_status
    END,
    attempt_count = attempt_count + 1,
    last_error = $2,
    updated_at = NOW()
WHERE id = $1
`

type FailQueueItemParams struct {
	ID        uuid.UUID `db:"id" json:"id"`
	LastError *string   `db:"last_error" json:"last_error"`
}

func (q *Queries) FailQueueItem(ctx context.Context, arg FailQueueItemParams) error {
	_, err := q.db.Exec(ctx, FailQueueItem, arg.ID, arg.LastError)
	return err
}

const GetQueueItem = `-- name: GetQueueItem :one
SELECT id, scheduled_post_id, status, priority, scheduled_for, attempt_count, max_attempts, last_error, worker_id, locked_at, lock_expires_at, completed_at, created_at, updated_at FROM post_queue
WHERE id = $1
`

func (q *Queries) GetQueueItem(ctx context.Context, id uuid.UUID) (PostQueue, error) {
	row := q.db.QueryRow(ctx, GetQueueItem, id)
	var i PostQueue
	err := row.Scan(
		&i.ID,
		&i.ScheduledPostID,
		&i.Status,
		&i.Priority,
		&i.ScheduledFor,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.LastError,
		&i.WorkerID,
		&i.LockedAt,
		&i.LockExpiresAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const LockNextQueueItems = `-- name: LockNextQueueItems :many
UPDATE post_queue SET 
    status = 'processing',
    worker_id = $1,
    locked_at = NOW(),
    lock_expires_at = NOW() + INTERVAL '5 minutes',
    updated_at = NOW()
WHERE id IN (
    SELECT pq.id 
    FROM post_queue pq
    WHERE pq.status = 'pending'
      AND pq.scheduled_for <= $2
      AND (pq.lock_expires_at IS NULL OR pq.lock_expires_at < NOW())
    ORDER BY pq.priority ASC, pq.scheduled_for ASC
    LIMIT $3
    FOR UPDATE SKIP LOCKED
)
RETURNING id, scheduled_post_id, status, priority, scheduled_for, attempt_count, max_attempts, last_error, worker_id, locked_at, lock_expires_at, completed_at, created_at, updated_at
`

type LockNextQueueItemsParams struct {
	WorkerID     *string   `db:"worker_id" json:"worker_id"`
	ScheduledFor time.Time `db:"scheduled_for" json:"scheduled_for"`
	Limit        int32     `db:"limit" json:"limit"`
}

func (q *Queries) LockNextQueueItems(ctx context.Context, arg LockNextQueueItemsParams) ([]PostQueue, error) {
	rows, err := q.db.Query(ctx, LockNextQueueItems, arg.WorkerID, arg.ScheduledFor, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PostQueue{}
	for rows.Next() {
		var i PostQueue
		if err := rows.Scan(
			&i.ID,
			&i.ScheduledPostID,
			&i.Status,
			&i.Priority,
			&i.ScheduledFor,
			&i.AttemptCount,
			&i.MaxAttempts,
			&i.LastError,
			&i.WorkerID,
			&i.LockedAt,
			&i.LockExpiresAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ResetStaleLocks = `-- name: ResetStaleLocks :exec
UPDATE post_queue SET 
    status = 'pending',
    worker_id = NULL,
    locked_at = NULL,
    lock_expires_at = NULL,
    updated_at = NOW()
WHERE status = 'processing'
  AND lock_expires_at < NOW()
`

func (q *Queries) ResetStaleLocks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, ResetStaleLocks)
	return err
}
