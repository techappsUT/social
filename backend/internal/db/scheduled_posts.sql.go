// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: scheduled_posts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CountScheduledPostsByTeam = `-- name: CountScheduledPostsByTeam :one
SELECT COUNT(*) FROM scheduled_posts
WHERE team_id = $1 
  AND status IN ('draft', 'scheduled', 'queued')
  AND deleted_at IS NULL
`

func (q *Queries) CountScheduledPostsByTeam(ctx context.Context, teamID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountScheduledPostsByTeam, teamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateScheduledPost = `-- name: CreateScheduledPost :one

INSERT INTO scheduled_posts (
    team_id,
    created_by,
    social_account_id,
    content,
    content_html,
    status,
    scheduled_at,
    platform_specific_options
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, team_id, created_by, social_account_id, content, content_html, shortened_links, status, scheduled_at, published_at, platform_specific_options, retry_count, error_message, created_at, updated_at, deleted_at
`

type CreateScheduledPostParams struct {
	TeamID                  uuid.UUID          `db:"team_id" json:"team_id"`
	CreatedBy               uuid.UUID          `db:"created_by" json:"created_by"`
	SocialAccountID         uuid.UUID          `db:"social_account_id" json:"social_account_id"`
	Content                 string             `db:"content" json:"content"`
	ContentHtml             *string            `db:"content_html" json:"content_html"`
	Status                  NullPostStatus     `db:"status" json:"status"`
	ScheduledAt             pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	PlatformSpecificOptions []byte             `db:"platform_specific_options" json:"platform_specific_options"`
}

// path: backend/sql/scheduled_posts.sql
func (q *Queries) CreateScheduledPost(ctx context.Context, arg CreateScheduledPostParams) (ScheduledPost, error) {
	row := q.db.QueryRow(ctx, CreateScheduledPost,
		arg.TeamID,
		arg.CreatedBy,
		arg.SocialAccountID,
		arg.Content,
		arg.ContentHtml,
		arg.Status,
		arg.ScheduledAt,
		arg.PlatformSpecificOptions,
	)
	var i ScheduledPost
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.CreatedBy,
		&i.SocialAccountID,
		&i.Content,
		&i.ContentHtml,
		&i.ShortenedLinks,
		&i.Status,
		&i.ScheduledAt,
		&i.PublishedAt,
		&i.PlatformSpecificOptions,
		&i.RetryCount,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const GetDuePosts = `-- name: GetDuePosts :many
SELECT sp.id, sp.team_id, sp.created_by, sp.social_account_id, sp.content, sp.content_html, sp.shortened_links, sp.status, sp.scheduled_at, sp.published_at, sp.platform_specific_options, sp.retry_count, sp.error_message, sp.created_at, sp.updated_at, sp.deleted_at, sa.platform
FROM scheduled_posts sp
INNER JOIN social_accounts sa ON sp.social_account_id = sa.id
WHERE sp.status IN ('scheduled', 'queued')
  AND sp.scheduled_at <= $1
  AND sp.deleted_at IS NULL
  AND sa.status = 'active'
  AND sa.deleted_at IS NULL
ORDER BY sp.scheduled_at ASC
LIMIT $2
`

type GetDuePostsParams struct {
	ScheduledAt pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	Limit       int32              `db:"limit" json:"limit"`
}

type GetDuePostsRow struct {
	ID                      uuid.UUID          `db:"id" json:"id"`
	TeamID                  uuid.UUID          `db:"team_id" json:"team_id"`
	CreatedBy               uuid.UUID          `db:"created_by" json:"created_by"`
	SocialAccountID         uuid.UUID          `db:"social_account_id" json:"social_account_id"`
	Content                 string             `db:"content" json:"content"`
	ContentHtml             *string            `db:"content_html" json:"content_html"`
	ShortenedLinks          []byte             `db:"shortened_links" json:"shortened_links"`
	Status                  NullPostStatus     `db:"status" json:"status"`
	ScheduledAt             pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	PublishedAt             pgtype.Timestamptz `db:"published_at" json:"published_at"`
	PlatformSpecificOptions []byte             `db:"platform_specific_options" json:"platform_specific_options"`
	RetryCount              *int32             `db:"retry_count" json:"retry_count"`
	ErrorMessage            *string            `db:"error_message" json:"error_message"`
	CreatedAt               pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt               pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	Platform                SocialPlatform     `db:"platform" json:"platform"`
}

func (q *Queries) GetDuePosts(ctx context.Context, arg GetDuePostsParams) ([]GetDuePostsRow, error) {
	rows, err := q.db.Query(ctx, GetDuePosts, arg.ScheduledAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDuePostsRow{}
	for rows.Next() {
		var i GetDuePostsRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.CreatedBy,
			&i.SocialAccountID,
			&i.Content,
			&i.ContentHtml,
			&i.ShortenedLinks,
			&i.Status,
			&i.ScheduledAt,
			&i.PublishedAt,
			&i.PlatformSpecificOptions,
			&i.RetryCount,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Platform,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetScheduledPostByID = `-- name: GetScheduledPostByID :one
SELECT id, team_id, created_by, social_account_id, content, content_html, shortened_links, status, scheduled_at, published_at, platform_specific_options, retry_count, error_message, created_at, updated_at, deleted_at FROM scheduled_posts
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetScheduledPostByID(ctx context.Context, id uuid.UUID) (ScheduledPost, error) {
	row := q.db.QueryRow(ctx, GetScheduledPostByID, id)
	var i ScheduledPost
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.CreatedBy,
		&i.SocialAccountID,
		&i.Content,
		&i.ContentHtml,
		&i.ShortenedLinks,
		&i.Status,
		&i.ScheduledAt,
		&i.PublishedAt,
		&i.PlatformSpecificOptions,
		&i.RetryCount,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const GetScheduledPostWithAccount = `-- name: GetScheduledPostWithAccount :one
SELECT 
    sp.id, sp.team_id, sp.created_by, sp.social_account_id, sp.content, sp.content_html, sp.shortened_links, sp.status, sp.scheduled_at, sp.published_at, sp.platform_specific_options, sp.retry_count, sp.error_message, sp.created_at, sp.updated_at, sp.deleted_at,
    sa.platform,
    sa.username,
    sa.display_name
FROM scheduled_posts sp
INNER JOIN social_accounts sa ON sp.social_account_id = sa.id
WHERE sp.id = $1 AND sp.deleted_at IS NULL
`

type GetScheduledPostWithAccountRow struct {
	ID                      uuid.UUID          `db:"id" json:"id"`
	TeamID                  uuid.UUID          `db:"team_id" json:"team_id"`
	CreatedBy               uuid.UUID          `db:"created_by" json:"created_by"`
	SocialAccountID         uuid.UUID          `db:"social_account_id" json:"social_account_id"`
	Content                 string             `db:"content" json:"content"`
	ContentHtml             *string            `db:"content_html" json:"content_html"`
	ShortenedLinks          []byte             `db:"shortened_links" json:"shortened_links"`
	Status                  NullPostStatus     `db:"status" json:"status"`
	ScheduledAt             pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	PublishedAt             pgtype.Timestamptz `db:"published_at" json:"published_at"`
	PlatformSpecificOptions []byte             `db:"platform_specific_options" json:"platform_specific_options"`
	RetryCount              *int32             `db:"retry_count" json:"retry_count"`
	ErrorMessage            *string            `db:"error_message" json:"error_message"`
	CreatedAt               pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt               pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	Platform                SocialPlatform     `db:"platform" json:"platform"`
	Username                *string            `db:"username" json:"username"`
	DisplayName             *string            `db:"display_name" json:"display_name"`
}

func (q *Queries) GetScheduledPostWithAccount(ctx context.Context, id uuid.UUID) (GetScheduledPostWithAccountRow, error) {
	row := q.db.QueryRow(ctx, GetScheduledPostWithAccount, id)
	var i GetScheduledPostWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.CreatedBy,
		&i.SocialAccountID,
		&i.Content,
		&i.ContentHtml,
		&i.ShortenedLinks,
		&i.Status,
		&i.ScheduledAt,
		&i.PublishedAt,
		&i.PlatformSpecificOptions,
		&i.RetryCount,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Platform,
		&i.Username,
		&i.DisplayName,
	)
	return i, err
}

const ListScheduledPostsByTeam = `-- name: ListScheduledPostsByTeam :many
SELECT 
    sp.id, sp.team_id, sp.created_by, sp.social_account_id, sp.content, sp.content_html, sp.shortened_links, sp.status, sp.scheduled_at, sp.published_at, sp.platform_specific_options, sp.retry_count, sp.error_message, sp.created_at, sp.updated_at, sp.deleted_at,
    sa.platform,
    sa.username,
    u.full_name as creator_name
FROM scheduled_posts sp
INNER JOIN social_accounts sa ON sp.social_account_id = sa.id
INNER JOIN users u ON sp.created_by = u.id
WHERE sp.team_id = $1 
  AND sp.deleted_at IS NULL
ORDER BY 
    CASE WHEN sp.scheduled_at IS NULL THEN 1 ELSE 0 END,
    sp.scheduled_at ASC,
    sp.created_at DESC
LIMIT $2 OFFSET $3
`

type ListScheduledPostsByTeamParams struct {
	TeamID uuid.UUID `db:"team_id" json:"team_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

type ListScheduledPostsByTeamRow struct {
	ID                      uuid.UUID          `db:"id" json:"id"`
	TeamID                  uuid.UUID          `db:"team_id" json:"team_id"`
	CreatedBy               uuid.UUID          `db:"created_by" json:"created_by"`
	SocialAccountID         uuid.UUID          `db:"social_account_id" json:"social_account_id"`
	Content                 string             `db:"content" json:"content"`
	ContentHtml             *string            `db:"content_html" json:"content_html"`
	ShortenedLinks          []byte             `db:"shortened_links" json:"shortened_links"`
	Status                  NullPostStatus     `db:"status" json:"status"`
	ScheduledAt             pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	PublishedAt             pgtype.Timestamptz `db:"published_at" json:"published_at"`
	PlatformSpecificOptions []byte             `db:"platform_specific_options" json:"platform_specific_options"`
	RetryCount              *int32             `db:"retry_count" json:"retry_count"`
	ErrorMessage            *string            `db:"error_message" json:"error_message"`
	CreatedAt               pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt               pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	Platform                SocialPlatform     `db:"platform" json:"platform"`
	Username                *string            `db:"username" json:"username"`
	CreatorName             *string            `db:"creator_name" json:"creator_name"`
}

func (q *Queries) ListScheduledPostsByTeam(ctx context.Context, arg ListScheduledPostsByTeamParams) ([]ListScheduledPostsByTeamRow, error) {
	rows, err := q.db.Query(ctx, ListScheduledPostsByTeam, arg.TeamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListScheduledPostsByTeamRow{}
	for rows.Next() {
		var i ListScheduledPostsByTeamRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.CreatedBy,
			&i.SocialAccountID,
			&i.Content,
			&i.ContentHtml,
			&i.ShortenedLinks,
			&i.Status,
			&i.ScheduledAt,
			&i.PublishedAt,
			&i.PlatformSpecificOptions,
			&i.RetryCount,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Platform,
			&i.Username,
			&i.CreatorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkPostFailed = `-- name: MarkPostFailed :exec
UPDATE scheduled_posts
SET 
    status = 'failed',
    error_message = $2,
    retry_count = retry_count + 1,
    updated_at = NOW()
WHERE id = $1
`

type MarkPostFailedParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	ErrorMessage *string   `db:"error_message" json:"error_message"`
}

func (q *Queries) MarkPostFailed(ctx context.Context, arg MarkPostFailedParams) error {
	_, err := q.db.Exec(ctx, MarkPostFailed, arg.ID, arg.ErrorMessage)
	return err
}

const MarkPostPublished = `-- name: MarkPostPublished :exec
UPDATE scheduled_posts
SET 
    status = 'published',
    published_at = $2,
    updated_at = NOW()
WHERE id = $1
`

type MarkPostPublishedParams struct {
	ID          uuid.UUID          `db:"id" json:"id"`
	PublishedAt pgtype.Timestamptz `db:"published_at" json:"published_at"`
}

func (q *Queries) MarkPostPublished(ctx context.Context, arg MarkPostPublishedParams) error {
	_, err := q.db.Exec(ctx, MarkPostPublished, arg.ID, arg.PublishedAt)
	return err
}

const SoftDeleteScheduledPost = `-- name: SoftDeleteScheduledPost :exec
UPDATE scheduled_posts
SET 
    deleted_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteScheduledPost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, SoftDeleteScheduledPost, id)
	return err
}

const UpdateScheduledPost = `-- name: UpdateScheduledPost :one
UPDATE scheduled_posts
SET 
    content = COALESCE($1, content),
    content_html = COALESCE($2, content_html),
    scheduled_at = COALESCE($3, scheduled_at),
    platform_specific_options = COALESCE($4, platform_specific_options),
    updated_at = NOW()
WHERE id = $5 AND deleted_at IS NULL
RETURNING id, team_id, created_by, social_account_id, content, content_html, shortened_links, status, scheduled_at, published_at, platform_specific_options, retry_count, error_message, created_at, updated_at, deleted_at
`

type UpdateScheduledPostParams struct {
	Content                 *string            `db:"content" json:"content"`
	ContentHtml             *string            `db:"content_html" json:"content_html"`
	ScheduledAt             pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	PlatformSpecificOptions []byte             `db:"platform_specific_options" json:"platform_specific_options"`
	ID                      uuid.UUID          `db:"id" json:"id"`
}

func (q *Queries) UpdateScheduledPost(ctx context.Context, arg UpdateScheduledPostParams) (ScheduledPost, error) {
	row := q.db.QueryRow(ctx, UpdateScheduledPost,
		arg.Content,
		arg.ContentHtml,
		arg.ScheduledAt,
		arg.PlatformSpecificOptions,
		arg.ID,
	)
	var i ScheduledPost
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.CreatedBy,
		&i.SocialAccountID,
		&i.Content,
		&i.ContentHtml,
		&i.ShortenedLinks,
		&i.Status,
		&i.ScheduledAt,
		&i.PublishedAt,
		&i.PlatformSpecificOptions,
		&i.RetryCount,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const UpdateScheduledPostStatus = `-- name: UpdateScheduledPostStatus :exec
UPDATE scheduled_posts
SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateScheduledPostStatusParams struct {
	ID     uuid.UUID      `db:"id" json:"id"`
	Status NullPostStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateScheduledPostStatus(ctx context.Context, arg UpdateScheduledPostStatusParams) error {
	_, err := q.db.Exec(ctx, UpdateScheduledPostStatus, arg.ID, arg.Status)
	return err
}
