// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: jobs.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const CompleteJobRun = `-- name: CompleteJobRun :exec
UPDATE job_runs
SET 
    status = 'completed',
    completed_at = NOW(),
    duration_ms = EXTRACT(EPOCH FROM (NOW() - started_at)) * 1000,
    result = $2,
    updated_at = NOW()
WHERE id = $1
`

type CompleteJobRunParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	Result []byte    `db:"result" json:"result"`
}

func (q *Queries) CompleteJobRun(ctx context.Context, arg CompleteJobRunParams) error {
	_, err := q.db.Exec(ctx, CompleteJobRun, arg.ID, arg.Result)
	return err
}

const CreateJobRun = `-- name: CreateJobRun :one

INSERT INTO job_runs (
    job_name,
    job_type,
    status,
    context,
    max_attempts
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, job_name, job_type, status, started_at, completed_at, duration_ms, worker_id, context, result, error_message, stack_trace, attempt_number, max_attempts, next_retry_at, created_at, updated_at
`

type CreateJobRunParams struct {
	JobName     string        `db:"job_name" json:"job_name"`
	JobType     string        `db:"job_type" json:"job_type"`
	Status      NullJobStatus `db:"status" json:"status"`
	Context     []byte        `db:"context" json:"context"`
	MaxAttempts *int32        `db:"max_attempts" json:"max_attempts"`
}

// path: backend/sql/jobs.sql
func (q *Queries) CreateJobRun(ctx context.Context, arg CreateJobRunParams) (JobRun, error) {
	row := q.db.QueryRow(ctx, CreateJobRun,
		arg.JobName,
		arg.JobType,
		arg.Status,
		arg.Context,
		arg.MaxAttempts,
	)
	var i JobRun
	err := row.Scan(
		&i.ID,
		&i.JobName,
		&i.JobType,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.WorkerID,
		&i.Context,
		&i.Result,
		&i.ErrorMessage,
		&i.StackTrace,
		&i.AttemptNumber,
		&i.MaxAttempts,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const FailJobRun = `-- name: FailJobRun :exec
UPDATE job_runs
SET 
    status = 'failed',
    completed_at = NOW(),
    duration_ms = EXTRACT(EPOCH FROM (NOW() - started_at)) * 1000,
    error_message = $2,
    stack_trace = $3,
    attempt_number = attempt_number + 1,
    next_retry_at = CASE 
        WHEN attempt_number < max_attempts 
        THEN NOW() + (INTERVAL '1 minute' * POWER(2, attempt_number))
        ELSE NULL
    END,
    updated_at = NOW()
WHERE id = $1
`

type FailJobRunParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	ErrorMessage *string   `db:"error_message" json:"error_message"`
	StackTrace   *string   `db:"stack_trace" json:"stack_trace"`
}

func (q *Queries) FailJobRun(ctx context.Context, arg FailJobRunParams) error {
	_, err := q.db.Exec(ctx, FailJobRun, arg.ID, arg.ErrorMessage, arg.StackTrace)
	return err
}

const GetJobRun = `-- name: GetJobRun :one
SELECT id, job_name, job_type, status, started_at, completed_at, duration_ms, worker_id, context, result, error_message, stack_trace, attempt_number, max_attempts, next_retry_at, created_at, updated_at FROM job_runs WHERE id = $1
`

func (q *Queries) GetJobRun(ctx context.Context, id uuid.UUID) (JobRun, error) {
	row := q.db.QueryRow(ctx, GetJobRun, id)
	var i JobRun
	err := row.Scan(
		&i.ID,
		&i.JobName,
		&i.JobType,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.WorkerID,
		&i.Context,
		&i.Result,
		&i.ErrorMessage,
		&i.StackTrace,
		&i.AttemptNumber,
		&i.MaxAttempts,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ListPendingRetries = `-- name: ListPendingRetries :many
SELECT id, job_name, job_type, status, started_at, completed_at, duration_ms, worker_id, context, result, error_message, stack_trace, attempt_number, max_attempts, next_retry_at, created_at, updated_at FROM job_runs
WHERE status = 'failed'
  AND next_retry_at IS NOT NULL
  AND next_retry_at <= NOW()
  AND attempt_number < max_attempts
ORDER BY next_retry_at ASC
LIMIT $1
`

func (q *Queries) ListPendingRetries(ctx context.Context, limit int32) ([]JobRun, error) {
	rows, err := q.db.Query(ctx, ListPendingRetries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobRun{}
	for rows.Next() {
		var i JobRun
		if err := rows.Scan(
			&i.ID,
			&i.JobName,
			&i.JobType,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.WorkerID,
			&i.Context,
			&i.Result,
			&i.ErrorMessage,
			&i.StackTrace,
			&i.AttemptNumber,
			&i.MaxAttempts,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRecentJobRuns = `-- name: ListRecentJobRuns :many
SELECT id, job_name, job_type, status, started_at, completed_at, duration_ms, worker_id, context, result, error_message, stack_trace, attempt_number, max_attempts, next_retry_at, created_at, updated_at FROM job_runs
WHERE job_name = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListRecentJobRunsParams struct {
	JobName string `db:"job_name" json:"job_name"`
	Limit   int32  `db:"limit" json:"limit"`
}

func (q *Queries) ListRecentJobRuns(ctx context.Context, arg ListRecentJobRunsParams) ([]JobRun, error) {
	rows, err := q.db.Query(ctx, ListRecentJobRuns, arg.JobName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobRun{}
	for rows.Next() {
		var i JobRun
		if err := rows.Scan(
			&i.ID,
			&i.JobName,
			&i.JobType,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.WorkerID,
			&i.Context,
			&i.Result,
			&i.ErrorMessage,
			&i.StackTrace,
			&i.AttemptNumber,
			&i.MaxAttempts,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const StartJobRun = `-- name: StartJobRun :exec
UPDATE job_runs
SET 
    status = 'running',
    started_at = NOW(),
    worker_id = $2,
    updated_at = NOW()
WHERE id = $1
`

type StartJobRunParams struct {
	ID       uuid.UUID `db:"id" json:"id"`
	WorkerID *string   `db:"worker_id" json:"worker_id"`
}

func (q *Queries) StartJobRun(ctx context.Context, arg StartJobRunParams) error {
	_, err := q.db.Exec(ctx, StartJobRun, arg.ID, arg.WorkerID)
	return err
}
