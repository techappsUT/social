// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: invoices.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateInvoice = `-- name: CreateInvoice :one

INSERT INTO invoices (
    subscription_id,
    team_id,
    stripe_invoice_id,
    invoice_number,
    status,
    subtotal,
    tax,
    total,
    amount_due,
    currency,
    invoice_date,
    due_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, subscription_id, team_id, stripe_invoice_id, invoice_number, status, subtotal, tax, total, amount_paid, amount_due, currency, invoice_date, due_date, paid_at, invoice_pdf_url, hosted_invoice_url, metadata, created_at, updated_at
`

type CreateInvoiceParams struct {
	SubscriptionID  uuid.UUID          `db:"subscription_id" json:"subscription_id"`
	TeamID          uuid.UUID          `db:"team_id" json:"team_id"`
	StripeInvoiceID *string            `db:"stripe_invoice_id" json:"stripe_invoice_id"`
	InvoiceNumber   *string            `db:"invoice_number" json:"invoice_number"`
	Status          NullInvoiceStatus  `db:"status" json:"status"`
	Subtotal        int64              `db:"subtotal" json:"subtotal"`
	Tax             *int64             `db:"tax" json:"tax"`
	Total           int64              `db:"total" json:"total"`
	AmountDue       int64              `db:"amount_due" json:"amount_due"`
	Currency        *string            `db:"currency" json:"currency"`
	InvoiceDate     pgtype.Timestamptz `db:"invoice_date" json:"invoice_date"`
	DueDate         pgtype.Timestamptz `db:"due_date" json:"due_date"`
}

// path: backend/sql/invoices.sql
func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, CreateInvoice,
		arg.SubscriptionID,
		arg.TeamID,
		arg.StripeInvoiceID,
		arg.InvoiceNumber,
		arg.Status,
		arg.Subtotal,
		arg.Tax,
		arg.Total,
		arg.AmountDue,
		arg.Currency,
		arg.InvoiceDate,
		arg.DueDate,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.TeamID,
		&i.StripeInvoiceID,
		&i.InvoiceNumber,
		&i.Status,
		&i.Subtotal,
		&i.Tax,
		&i.Total,
		&i.AmountPaid,
		&i.AmountDue,
		&i.Currency,
		&i.InvoiceDate,
		&i.DueDate,
		&i.PaidAt,
		&i.InvoicePdfUrl,
		&i.HostedInvoiceUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetInvoiceByID = `-- name: GetInvoiceByID :one
SELECT id, subscription_id, team_id, stripe_invoice_id, invoice_number, status, subtotal, tax, total, amount_paid, amount_due, currency, invoice_date, due_date, paid_at, invoice_pdf_url, hosted_invoice_url, metadata, created_at, updated_at FROM invoices WHERE id = $1
`

func (q *Queries) GetInvoiceByID(ctx context.Context, id uuid.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, GetInvoiceByID, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.TeamID,
		&i.StripeInvoiceID,
		&i.InvoiceNumber,
		&i.Status,
		&i.Subtotal,
		&i.Tax,
		&i.Total,
		&i.AmountPaid,
		&i.AmountDue,
		&i.Currency,
		&i.InvoiceDate,
		&i.DueDate,
		&i.PaidAt,
		&i.InvoicePdfUrl,
		&i.HostedInvoiceUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetInvoiceByStripeID = `-- name: GetInvoiceByStripeID :one
SELECT id, subscription_id, team_id, stripe_invoice_id, invoice_number, status, subtotal, tax, total, amount_paid, amount_due, currency, invoice_date, due_date, paid_at, invoice_pdf_url, hosted_invoice_url, metadata, created_at, updated_at FROM invoices WHERE stripe_invoice_id = $1
`

func (q *Queries) GetInvoiceByStripeID(ctx context.Context, stripeInvoiceID *string) (Invoice, error) {
	row := q.db.QueryRow(ctx, GetInvoiceByStripeID, stripeInvoiceID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.TeamID,
		&i.StripeInvoiceID,
		&i.InvoiceNumber,
		&i.Status,
		&i.Subtotal,
		&i.Tax,
		&i.Total,
		&i.AmountPaid,
		&i.AmountDue,
		&i.Currency,
		&i.InvoiceDate,
		&i.DueDate,
		&i.PaidAt,
		&i.InvoicePdfUrl,
		&i.HostedInvoiceUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ListInvoicesByTeam = `-- name: ListInvoicesByTeam :many
SELECT id, subscription_id, team_id, stripe_invoice_id, invoice_number, status, subtotal, tax, total, amount_paid, amount_due, currency, invoice_date, due_date, paid_at, invoice_pdf_url, hosted_invoice_url, metadata, created_at, updated_at FROM invoices
WHERE team_id = $1
ORDER BY invoice_date DESC
LIMIT $2 OFFSET $3
`

type ListInvoicesByTeamParams struct {
	TeamID uuid.UUID `db:"team_id" json:"team_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListInvoicesByTeam(ctx context.Context, arg ListInvoicesByTeamParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, ListInvoicesByTeam, arg.TeamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.TeamID,
			&i.StripeInvoiceID,
			&i.InvoiceNumber,
			&i.Status,
			&i.Subtotal,
			&i.Tax,
			&i.Total,
			&i.AmountPaid,
			&i.AmountDue,
			&i.Currency,
			&i.InvoiceDate,
			&i.DueDate,
			&i.PaidAt,
			&i.InvoicePdfUrl,
			&i.HostedInvoiceUrl,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateInvoiceStatus = `-- name: UpdateInvoiceStatus :exec
UPDATE invoices
SET 
    status = $2,
    amount_paid = COALESCE($3, amount_paid),
    paid_at = COALESCE($4, paid_at),
    invoice_pdf_url = COALESCE($5, invoice_pdf_url),
    hosted_invoice_url = COALESCE($6, hosted_invoice_url),
    updated_at = NOW()
WHERE id = $1
`

type UpdateInvoiceStatusParams struct {
	ID               uuid.UUID          `db:"id" json:"id"`
	Status           NullInvoiceStatus  `db:"status" json:"status"`
	AmountPaid       *int64             `db:"amount_paid" json:"amount_paid"`
	PaidAt           pgtype.Timestamptz `db:"paid_at" json:"paid_at"`
	InvoicePdfUrl    *string            `db:"invoice_pdf_url" json:"invoice_pdf_url"`
	HostedInvoiceUrl *string            `db:"hosted_invoice_url" json:"hosted_invoice_url"`
}

func (q *Queries) UpdateInvoiceStatus(ctx context.Context, arg UpdateInvoiceStatusParams) error {
	_, err := q.db.Exec(ctx, UpdateInvoiceStatus,
		arg.ID,
		arg.Status,
		arg.AmountPaid,
		arg.PaidAt,
		arg.InvoicePdfUrl,
		arg.HostedInvoiceUrl,
	)
	return err
}
