// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscriptions.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CancelSubscription = `-- name: CancelSubscription :exec
UPDATE subscriptions
SET 
    cancel_at_period_end = true,
    canceled_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) CancelSubscription(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, CancelSubscription, id)
	return err
}

const CreateSubscription = `-- name: CreateSubscription :one

INSERT INTO subscriptions (
    team_id,
    plan_id,
    status,
    stripe_subscription_id,
    stripe_customer_id,
    current_period_start,
    current_period_end,
    trial_start,
    trial_end
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, team_id, plan_id, status, interval, stripe_subscription_id, stripe_customer_id, current_period_start, current_period_end, cancel_at_period_end, canceled_at, trial_start, trial_end, created_at, updated_at
`

type CreateSubscriptionParams struct {
	TeamID               uuid.UUID              `db:"team_id" json:"team_id"`
	PlanID               uuid.UUID              `db:"plan_id" json:"plan_id"`
	Status               NullSubscriptionStatus `db:"status" json:"status"`
	StripeSubscriptionID *string                `db:"stripe_subscription_id" json:"stripe_subscription_id"`
	StripeCustomerID     *string                `db:"stripe_customer_id" json:"stripe_customer_id"`
	CurrentPeriodStart   pgtype.Timestamptz     `db:"current_period_start" json:"current_period_start"`
	CurrentPeriodEnd     pgtype.Timestamptz     `db:"current_period_end" json:"current_period_end"`
	TrialStart           pgtype.Timestamptz     `db:"trial_start" json:"trial_start"`
	TrialEnd             pgtype.Timestamptz     `db:"trial_end" json:"trial_end"`
}

// path: backend/sql/subscriptions.sql
func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, CreateSubscription,
		arg.TeamID,
		arg.PlanID,
		arg.Status,
		arg.StripeSubscriptionID,
		arg.StripeCustomerID,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.TrialStart,
		arg.TrialEnd,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.PlanID,
		&i.Status,
		&i.Interval,
		&i.StripeSubscriptionID,
		&i.StripeCustomerID,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CanceledAt,
		&i.TrialStart,
		&i.TrialEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSubscriptionByStripeID = `-- name: GetSubscriptionByStripeID :one
SELECT id, team_id, plan_id, status, interval, stripe_subscription_id, stripe_customer_id, current_period_start, current_period_end, cancel_at_period_end, canceled_at, trial_start, trial_end, created_at, updated_at FROM subscriptions
WHERE stripe_subscription_id = $1
`

func (q *Queries) GetSubscriptionByStripeID(ctx context.Context, stripeSubscriptionID *string) (Subscription, error) {
	row := q.db.QueryRow(ctx, GetSubscriptionByStripeID, stripeSubscriptionID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.PlanID,
		&i.Status,
		&i.Interval,
		&i.StripeSubscriptionID,
		&i.StripeCustomerID,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CanceledAt,
		&i.TrialStart,
		&i.TrialEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSubscriptionByTeamID = `-- name: GetSubscriptionByTeamID :one
SELECT s.id, s.team_id, s.plan_id, s.status, s.interval, s.stripe_subscription_id, s.stripe_customer_id, s.current_period_start, s.current_period_end, s.cancel_at_period_end, s.canceled_at, s.trial_start, s.trial_end, s.created_at, s.updated_at, p.name as plan_name, p.features as plan_features
FROM subscriptions s
INNER JOIN plans p ON s.plan_id = p.id
WHERE s.team_id = $1
`

type GetSubscriptionByTeamIDRow struct {
	ID                   uuid.UUID              `db:"id" json:"id"`
	TeamID               uuid.UUID              `db:"team_id" json:"team_id"`
	PlanID               uuid.UUID              `db:"plan_id" json:"plan_id"`
	Status               NullSubscriptionStatus `db:"status" json:"status"`
	Interval             PlanInterval           `db:"interval" json:"interval"`
	StripeSubscriptionID *string                `db:"stripe_subscription_id" json:"stripe_subscription_id"`
	StripeCustomerID     *string                `db:"stripe_customer_id" json:"stripe_customer_id"`
	CurrentPeriodStart   pgtype.Timestamptz     `db:"current_period_start" json:"current_period_start"`
	CurrentPeriodEnd     pgtype.Timestamptz     `db:"current_period_end" json:"current_period_end"`
	CancelAtPeriodEnd    *bool                  `db:"cancel_at_period_end" json:"cancel_at_period_end"`
	CanceledAt           pgtype.Timestamptz     `db:"canceled_at" json:"canceled_at"`
	TrialStart           pgtype.Timestamptz     `db:"trial_start" json:"trial_start"`
	TrialEnd             pgtype.Timestamptz     `db:"trial_end" json:"trial_end"`
	CreatedAt            pgtype.Timestamptz     `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz     `db:"updated_at" json:"updated_at"`
	PlanName             string                 `db:"plan_name" json:"plan_name"`
	PlanFeatures         []byte                 `db:"plan_features" json:"plan_features"`
}

func (q *Queries) GetSubscriptionByTeamID(ctx context.Context, teamID uuid.UUID) (GetSubscriptionByTeamIDRow, error) {
	row := q.db.QueryRow(ctx, GetSubscriptionByTeamID, teamID)
	var i GetSubscriptionByTeamIDRow
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.PlanID,
		&i.Status,
		&i.Interval,
		&i.StripeSubscriptionID,
		&i.StripeCustomerID,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CanceledAt,
		&i.TrialStart,
		&i.TrialEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PlanName,
		&i.PlanFeatures,
	)
	return i, err
}

const ListExpiringSubscriptions = `-- name: ListExpiringSubscriptions :many
SELECT s.id, s.team_id, s.plan_id, s.status, s.interval, s.stripe_subscription_id, s.stripe_customer_id, s.current_period_start, s.current_period_end, s.cancel_at_period_end, s.canceled_at, s.trial_start, s.trial_end, s.created_at, s.updated_at, t.name as team_name
FROM subscriptions s
INNER JOIN teams t ON s.team_id = t.id
WHERE s.status = 'active'
  AND s.current_period_end BETWEEN $1 AND $2
  AND s.cancel_at_period_end = false
ORDER BY s.current_period_end ASC
`

type ListExpiringSubscriptionsParams struct {
	CurrentPeriodEnd   pgtype.Timestamptz `db:"current_period_end" json:"current_period_end"`
	CurrentPeriodEnd_2 pgtype.Timestamptz `db:"current_period_end_2" json:"current_period_end_2"`
}

type ListExpiringSubscriptionsRow struct {
	ID                   uuid.UUID              `db:"id" json:"id"`
	TeamID               uuid.UUID              `db:"team_id" json:"team_id"`
	PlanID               uuid.UUID              `db:"plan_id" json:"plan_id"`
	Status               NullSubscriptionStatus `db:"status" json:"status"`
	Interval             PlanInterval           `db:"interval" json:"interval"`
	StripeSubscriptionID *string                `db:"stripe_subscription_id" json:"stripe_subscription_id"`
	StripeCustomerID     *string                `db:"stripe_customer_id" json:"stripe_customer_id"`
	CurrentPeriodStart   pgtype.Timestamptz     `db:"current_period_start" json:"current_period_start"`
	CurrentPeriodEnd     pgtype.Timestamptz     `db:"current_period_end" json:"current_period_end"`
	CancelAtPeriodEnd    *bool                  `db:"cancel_at_period_end" json:"cancel_at_period_end"`
	CanceledAt           pgtype.Timestamptz     `db:"canceled_at" json:"canceled_at"`
	TrialStart           pgtype.Timestamptz     `db:"trial_start" json:"trial_start"`
	TrialEnd             pgtype.Timestamptz     `db:"trial_end" json:"trial_end"`
	CreatedAt            pgtype.Timestamptz     `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz     `db:"updated_at" json:"updated_at"`
	TeamName             string                 `db:"team_name" json:"team_name"`
}

func (q *Queries) ListExpiringSubscriptions(ctx context.Context, arg ListExpiringSubscriptionsParams) ([]ListExpiringSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, ListExpiringSubscriptions, arg.CurrentPeriodEnd, arg.CurrentPeriodEnd_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpiringSubscriptionsRow{}
	for rows.Next() {
		var i ListExpiringSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.PlanID,
			&i.Status,
			&i.Interval,
			&i.StripeSubscriptionID,
			&i.StripeCustomerID,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CancelAtPeriodEnd,
			&i.CanceledAt,
			&i.TrialStart,
			&i.TrialEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TeamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :exec
UPDATE subscriptions
SET 
    status = $2,
    current_period_start = COALESCE($3, current_period_start),
    current_period_end = COALESCE($4, current_period_end),
    updated_at = NOW()
WHERE id = $1
`

type UpdateSubscriptionStatusParams struct {
	ID                 uuid.UUID              `db:"id" json:"id"`
	Status             NullSubscriptionStatus `db:"status" json:"status"`
	CurrentPeriodStart pgtype.Timestamptz     `db:"current_period_start" json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz     `db:"current_period_end" json:"current_period_end"`
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) error {
	_, err := q.db.Exec(ctx, UpdateSubscriptionStatus,
		arg.ID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
	)
	return err
}
