// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: analytics.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateAnalyticsEvent = `-- name: CreateAnalyticsEvent :one

INSERT INTO analytics_events (
    post_id,
    event_type,
    event_value,
    event_metadata
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, post_id, event_type, event_value, event_metadata, recorded_at
`

type CreateAnalyticsEventParams struct {
	PostID        uuid.UUID `db:"post_id" json:"post_id"`
	EventType     EventType `db:"event_type" json:"event_type"`
	EventValue    *int32    `db:"event_value" json:"event_value"`
	EventMetadata []byte    `db:"event_metadata" json:"event_metadata"`
}

// path: backend/sql/analytics.sql
// ðŸ”„ REFACTORED - Match actual schema (recorded_at, no team_id, no event_timestamp)
func (q *Queries) CreateAnalyticsEvent(ctx context.Context, arg CreateAnalyticsEventParams) (AnalyticsEvent, error) {
	row := q.db.QueryRow(ctx, CreateAnalyticsEvent,
		arg.PostID,
		arg.EventType,
		arg.EventValue,
		arg.EventMetadata,
	)
	var i AnalyticsEvent
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.EventType,
		&i.EventValue,
		&i.EventMetadata,
		&i.RecordedAt,
	)
	return i, err
}

const GetAnalyticsEventsByDateRange = `-- name: GetAnalyticsEventsByDateRange :many
SELECT ae.id, ae.post_id, ae.event_type, ae.event_value, ae.event_metadata, ae.recorded_at
FROM analytics_events ae
INNER JOIN posts p ON ae.post_id = p.id
WHERE p.team_id = $1
  AND ae.recorded_at BETWEEN $2 AND $3
ORDER BY ae.recorded_at DESC
LIMIT $4 OFFSET $5
`

type GetAnalyticsEventsByDateRangeParams struct {
	TeamID       uuid.UUID          `db:"team_id" json:"team_id"`
	RecordedAt   pgtype.Timestamptz `db:"recorded_at" json:"recorded_at"`
	RecordedAt_2 pgtype.Timestamptz `db:"recorded_at_2" json:"recorded_at_2"`
	Limit        int32              `db:"limit" json:"limit"`
	Offset       int32              `db:"offset" json:"offset"`
}

func (q *Queries) GetAnalyticsEventsByDateRange(ctx context.Context, arg GetAnalyticsEventsByDateRangeParams) ([]AnalyticsEvent, error) {
	rows, err := q.db.Query(ctx, GetAnalyticsEventsByDateRange,
		arg.TeamID,
		arg.RecordedAt,
		arg.RecordedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnalyticsEvent{}
	for rows.Next() {
		var i AnalyticsEvent
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.EventType,
			&i.EventValue,
			&i.EventMetadata,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAnalyticsEventsByPost = `-- name: GetAnalyticsEventsByPost :many
SELECT id, post_id, event_type, event_value, event_metadata, recorded_at FROM analytics_events
WHERE post_id = $1
ORDER BY recorded_at DESC
`

func (q *Queries) GetAnalyticsEventsByPost(ctx context.Context, postID uuid.UUID) ([]AnalyticsEvent, error) {
	rows, err := q.db.Query(ctx, GetAnalyticsEventsByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnalyticsEvent{}
	for rows.Next() {
		var i AnalyticsEvent
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.EventType,
			&i.EventValue,
			&i.EventMetadata,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAnalyticsSummaryByTeam = `-- name: GetAnalyticsSummaryByTeam :one
SELECT 
    COUNT(DISTINCT ae.post_id) as total_posts,
    COUNT(*) as total_events,
    COUNT(*) FILTER (WHERE ae.event_type = 'impression') as total_impressions,
    COUNT(*) FILTER (WHERE ae.event_type IN ('like', 'share', 'comment')) as total_engagements,
    COUNT(*) FILTER (WHERE ae.event_type = 'click') as total_clicks
FROM analytics_events ae
INNER JOIN posts p ON ae.post_id = p.id
WHERE p.team_id = $1
  AND ae.recorded_at BETWEEN $2 AND $3
`

type GetAnalyticsSummaryByTeamParams struct {
	TeamID       uuid.UUID          `db:"team_id" json:"team_id"`
	RecordedAt   pgtype.Timestamptz `db:"recorded_at" json:"recorded_at"`
	RecordedAt_2 pgtype.Timestamptz `db:"recorded_at_2" json:"recorded_at_2"`
}

type GetAnalyticsSummaryByTeamRow struct {
	TotalPosts       int64 `db:"total_posts" json:"total_posts"`
	TotalEvents      int64 `db:"total_events" json:"total_events"`
	TotalImpressions int64 `db:"total_impressions" json:"total_impressions"`
	TotalEngagements int64 `db:"total_engagements" json:"total_engagements"`
	TotalClicks      int64 `db:"total_clicks" json:"total_clicks"`
}

func (q *Queries) GetAnalyticsSummaryByTeam(ctx context.Context, arg GetAnalyticsSummaryByTeamParams) (GetAnalyticsSummaryByTeamRow, error) {
	row := q.db.QueryRow(ctx, GetAnalyticsSummaryByTeam, arg.TeamID, arg.RecordedAt, arg.RecordedAt_2)
	var i GetAnalyticsSummaryByTeamRow
	err := row.Scan(
		&i.TotalPosts,
		&i.TotalEvents,
		&i.TotalImpressions,
		&i.TotalEngagements,
		&i.TotalClicks,
	)
	return i, err
}

const GetEventCountByType = `-- name: GetEventCountByType :many
SELECT 
    event_type,
    COUNT(*) as event_count,
    SUM(event_value) as total_value
FROM analytics_events
WHERE post_id = $1
GROUP BY event_type
ORDER BY total_value DESC
`

type GetEventCountByTypeRow struct {
	EventType  EventType `db:"event_type" json:"event_type"`
	EventCount int64     `db:"event_count" json:"event_count"`
	TotalValue int64     `db:"total_value" json:"total_value"`
}

func (q *Queries) GetEventCountByType(ctx context.Context, postID uuid.UUID) ([]GetEventCountByTypeRow, error) {
	rows, err := q.db.Query(ctx, GetEventCountByType, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventCountByTypeRow{}
	for rows.Next() {
		var i GetEventCountByTypeRow
		if err := rows.Scan(&i.EventType, &i.EventCount, &i.TotalValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
