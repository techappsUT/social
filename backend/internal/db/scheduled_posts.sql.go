// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: scheduled_posts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CountScheduledPostsByTeam = `-- name: CountScheduledPostsByTeam :one
SELECT COUNT(*)
FROM scheduled_posts
WHERE team_id = $1 
  AND deleted_at IS NULL
`

func (q *Queries) CountScheduledPostsByTeam(ctx context.Context, teamID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountScheduledPostsByTeam, teamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateScheduledPost = `-- name: CreateScheduledPost :one

INSERT INTO scheduled_posts (
    team_id,
    created_by,
    social_account_id,
    content,
    content_html,
    shortened_links,
    status,
    scheduled_at,
    platform_specific_options
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, team_id, created_by, social_account_id, content, content_html, shortened_links, status, scheduled_at, published_at, platform_specific_options, error_message, retry_count, max_retries, created_at, updated_at, deleted_at
`

type CreateScheduledPostParams struct {
	TeamID                  uuid.UUID          `db:"team_id" json:"team_id"`
	CreatedBy               uuid.UUID          `db:"created_by" json:"created_by"`
	SocialAccountID         uuid.UUID          `db:"social_account_id" json:"social_account_id"`
	Content                 string             `db:"content" json:"content"`
	ContentHtml             *string            `db:"content_html" json:"content_html"`
	ShortenedLinks          []byte             `db:"shortened_links" json:"shortened_links"`
	Status                  NullPostStatus     `db:"status" json:"status"`
	ScheduledAt             pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	PlatformSpecificOptions []byte             `db:"platform_specific_options" json:"platform_specific_options"`
}

// path: backend/sql/scheduled_posts.sql
// âœ… KEEP - Verify this file exists with these queries
func (q *Queries) CreateScheduledPost(ctx context.Context, arg CreateScheduledPostParams) (ScheduledPost, error) {
	row := q.db.QueryRow(ctx, CreateScheduledPost,
		arg.TeamID,
		arg.CreatedBy,
		arg.SocialAccountID,
		arg.Content,
		arg.ContentHtml,
		arg.ShortenedLinks,
		arg.Status,
		arg.ScheduledAt,
		arg.PlatformSpecificOptions,
	)
	var i ScheduledPost
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.CreatedBy,
		&i.SocialAccountID,
		&i.Content,
		&i.ContentHtml,
		&i.ShortenedLinks,
		&i.Status,
		&i.ScheduledAt,
		&i.PublishedAt,
		&i.PlatformSpecificOptions,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const GetDuePosts = `-- name: GetDuePosts :many
SELECT sp.id, sp.team_id, sp.created_by, sp.social_account_id, sp.content, sp.content_html, sp.shortened_links, sp.status, sp.scheduled_at, sp.published_at, sp.platform_specific_options, sp.error_message, sp.retry_count, sp.max_retries, sp.created_at, sp.updated_at, sp.deleted_at, sa.platform
FROM scheduled_posts sp
INNER JOIN social_accounts sa ON sp.social_account_id = sa.id
WHERE sp.status IN ('scheduled', 'queued')
  AND sp.scheduled_at <= $1
  AND sp.deleted_at IS NULL
  AND sa.status = 'active'
  AND sa.deleted_at IS NULL
ORDER BY sp.scheduled_at ASC
LIMIT $2
`

type GetDuePostsParams struct {
	ScheduledAt pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	Limit       int32              `db:"limit" json:"limit"`
}

type GetDuePostsRow struct {
	ID                      uuid.UUID          `db:"id" json:"id"`
	TeamID                  uuid.UUID          `db:"team_id" json:"team_id"`
	CreatedBy               uuid.UUID          `db:"created_by" json:"created_by"`
	SocialAccountID         uuid.UUID          `db:"social_account_id" json:"social_account_id"`
	Content                 string             `db:"content" json:"content"`
	ContentHtml             *string            `db:"content_html" json:"content_html"`
	ShortenedLinks          []byte             `db:"shortened_links" json:"shortened_links"`
	Status                  NullPostStatus     `db:"status" json:"status"`
	ScheduledAt             pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	PublishedAt             pgtype.Timestamptz `db:"published_at" json:"published_at"`
	PlatformSpecificOptions []byte             `db:"platform_specific_options" json:"platform_specific_options"`
	ErrorMessage            *string            `db:"error_message" json:"error_message"`
	RetryCount              *int32             `db:"retry_count" json:"retry_count"`
	MaxRetries              *int32             `db:"max_retries" json:"max_retries"`
	CreatedAt               pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt               pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	Platform                SocialPlatform     `db:"platform" json:"platform"`
}

func (q *Queries) GetDuePosts(ctx context.Context, arg GetDuePostsParams) ([]GetDuePostsRow, error) {
	rows, err := q.db.Query(ctx, GetDuePosts, arg.ScheduledAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDuePostsRow{}
	for rows.Next() {
		var i GetDuePostsRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.CreatedBy,
			&i.SocialAccountID,
			&i.Content,
			&i.ContentHtml,
			&i.ShortenedLinks,
			&i.Status,
			&i.ScheduledAt,
			&i.PublishedAt,
			&i.PlatformSpecificOptions,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Platform,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetScheduledPostByID = `-- name: GetScheduledPostByID :one
SELECT id, team_id, created_by, social_account_id, content, content_html, shortened_links, status, scheduled_at, published_at, platform_specific_options, error_message, retry_count, max_retries, created_at, updated_at, deleted_at FROM scheduled_posts
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetScheduledPostByID(ctx context.Context, id uuid.UUID) (ScheduledPost, error) {
	row := q.db.QueryRow(ctx, GetScheduledPostByID, id)
	var i ScheduledPost
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.CreatedBy,
		&i.SocialAccountID,
		&i.Content,
		&i.ContentHtml,
		&i.ShortenedLinks,
		&i.Status,
		&i.ScheduledAt,
		&i.PublishedAt,
		&i.PlatformSpecificOptions,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const IncrementRetryCount = `-- name: IncrementRetryCount :exec
UPDATE scheduled_posts
SET 
    retry_count = retry_count + 1,
    error_message = $2,
    updated_at = NOW()
WHERE id = $1
`

type IncrementRetryCountParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	ErrorMessage *string   `db:"error_message" json:"error_message"`
}

func (q *Queries) IncrementRetryCount(ctx context.Context, arg IncrementRetryCountParams) error {
	_, err := q.db.Exec(ctx, IncrementRetryCount, arg.ID, arg.ErrorMessage)
	return err
}

const ListScheduledPostsByTeam = `-- name: ListScheduledPostsByTeam :many
SELECT id, team_id, created_by, social_account_id, content, content_html, shortened_links, status, scheduled_at, published_at, platform_specific_options, error_message, retry_count, max_retries, created_at, updated_at, deleted_at FROM scheduled_posts
WHERE team_id = $1 
  AND deleted_at IS NULL
ORDER BY scheduled_at DESC
LIMIT $2 OFFSET $3
`

type ListScheduledPostsByTeamParams struct {
	TeamID uuid.UUID `db:"team_id" json:"team_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListScheduledPostsByTeam(ctx context.Context, arg ListScheduledPostsByTeamParams) ([]ScheduledPost, error) {
	rows, err := q.db.Query(ctx, ListScheduledPostsByTeam, arg.TeamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScheduledPost{}
	for rows.Next() {
		var i ScheduledPost
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.CreatedBy,
			&i.SocialAccountID,
			&i.Content,
			&i.ContentHtml,
			&i.ShortenedLinks,
			&i.Status,
			&i.ScheduledAt,
			&i.PublishedAt,
			&i.PlatformSpecificOptions,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SoftDeleteScheduledPost = `-- name: SoftDeleteScheduledPost :exec
UPDATE scheduled_posts
SET 
    deleted_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteScheduledPost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, SoftDeleteScheduledPost, id)
	return err
}

const UpdateScheduledPost = `-- name: UpdateScheduledPost :one
UPDATE scheduled_posts
SET 
    content = COALESCE($1, content),
    content_html = COALESCE($2, content_html),
    scheduled_at = COALESCE($3, scheduled_at),
    platform_specific_options = COALESCE($4, platform_specific_options),
    updated_at = NOW()
WHERE id = $5 AND deleted_at IS NULL
RETURNING id, team_id, created_by, social_account_id, content, content_html, shortened_links, status, scheduled_at, published_at, platform_specific_options, error_message, retry_count, max_retries, created_at, updated_at, deleted_at
`

type UpdateScheduledPostParams struct {
	Content                 *string            `db:"content" json:"content"`
	ContentHtml             *string            `db:"content_html" json:"content_html"`
	ScheduledAt             pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	PlatformSpecificOptions []byte             `db:"platform_specific_options" json:"platform_specific_options"`
	ID                      uuid.UUID          `db:"id" json:"id"`
}

func (q *Queries) UpdateScheduledPost(ctx context.Context, arg UpdateScheduledPostParams) (ScheduledPost, error) {
	row := q.db.QueryRow(ctx, UpdateScheduledPost,
		arg.Content,
		arg.ContentHtml,
		arg.ScheduledAt,
		arg.PlatformSpecificOptions,
		arg.ID,
	)
	var i ScheduledPost
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.CreatedBy,
		&i.SocialAccountID,
		&i.Content,
		&i.ContentHtml,
		&i.ShortenedLinks,
		&i.Status,
		&i.ScheduledAt,
		&i.PublishedAt,
		&i.PlatformSpecificOptions,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const UpdateScheduledPostStatus = `-- name: UpdateScheduledPostStatus :exec
UPDATE scheduled_posts
SET 
    status = $2,
    error_message = COALESCE($3, error_message),
    retry_count = COALESCE($4, retry_count),
    published_at = COALESCE($5, published_at),
    updated_at = NOW()
WHERE id = $1
`

type UpdateScheduledPostStatusParams struct {
	ID           uuid.UUID          `db:"id" json:"id"`
	Status       NullPostStatus     `db:"status" json:"status"`
	ErrorMessage *string            `db:"error_message" json:"error_message"`
	RetryCount   *int32             `db:"retry_count" json:"retry_count"`
	PublishedAt  pgtype.Timestamptz `db:"published_at" json:"published_at"`
}

func (q *Queries) UpdateScheduledPostStatus(ctx context.Context, arg UpdateScheduledPostStatusParams) error {
	_, err := q.db.Exec(ctx, UpdateScheduledPostStatus,
		arg.ID,
		arg.Status,
		arg.ErrorMessage,
		arg.RetryCount,
		arg.PublishedAt,
	)
	return err
}
