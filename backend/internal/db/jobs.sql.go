// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: jobs.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const CompleteJobRun = `-- name: CompleteJobRun :exec
UPDATE job_runs
SET 
    status = 'completed',
    result = $2,
    completed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

type CompleteJobRunParams struct {
	ID     uuid.UUID             `db:"id" json:"id"`
	Result pqtype.NullRawMessage `db:"result" json:"result"`
}

func (q *Queries) CompleteJobRun(ctx context.Context, arg CompleteJobRunParams) error {
	_, err := q.db.ExecContext(ctx, CompleteJobRun, arg.ID, arg.Result)
	return err
}

const CreateJobRun = `-- name: CreateJobRun :one

INSERT INTO job_runs (
    job_name,
    status,
    payload,
    started_at
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, job_name, status, payload, result, error, started_at, completed_at, created_at, updated_at
`

type CreateJobRunParams struct {
	JobName   string                `db:"job_name" json:"job_name"`
	Status    NullJobStatus         `db:"status" json:"status"`
	Payload   pqtype.NullRawMessage `db:"payload" json:"payload"`
	StartedAt sql.NullTime          `db:"started_at" json:"started_at"`
}

// path: backend/sql/jobs.sql
// ðŸ”„ REFACTORED - Match actual job_runs schema
func (q *Queries) CreateJobRun(ctx context.Context, arg CreateJobRunParams) (JobRun, error) {
	row := q.db.QueryRowContext(ctx, CreateJobRun,
		arg.JobName,
		arg.Status,
		arg.Payload,
		arg.StartedAt,
	)
	var i JobRun
	err := row.Scan(
		&i.ID,
		&i.JobName,
		&i.Status,
		&i.Payload,
		&i.Result,
		&i.Error,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const FailJobRun = `-- name: FailJobRun :exec
UPDATE job_runs
SET 
    status = 'failed',
    error = $2,
    completed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

type FailJobRunParams struct {
	ID    uuid.UUID      `db:"id" json:"id"`
	Error sql.NullString `db:"error" json:"error"`
}

func (q *Queries) FailJobRun(ctx context.Context, arg FailJobRunParams) error {
	_, err := q.db.ExecContext(ctx, FailJobRun, arg.ID, arg.Error)
	return err
}

const GetJobRunByID = `-- name: GetJobRunByID :one
SELECT id, job_name, status, payload, result, error, started_at, completed_at, created_at, updated_at FROM job_runs WHERE id = $1
`

func (q *Queries) GetJobRunByID(ctx context.Context, id uuid.UUID) (JobRun, error) {
	row := q.db.QueryRowContext(ctx, GetJobRunByID, id)
	var i JobRun
	err := row.Scan(
		&i.ID,
		&i.JobName,
		&i.Status,
		&i.Payload,
		&i.Result,
		&i.Error,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ListFailedJobRuns = `-- name: ListFailedJobRuns :many
SELECT id, job_name, status, payload, result, error, started_at, completed_at, created_at, updated_at
FROM job_runs
WHERE status = 'failed'
  AND created_at >= $1
ORDER BY created_at DESC
LIMIT $2
`

type ListFailedJobRunsParams struct {
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
	Limit     int32        `db:"limit" json:"limit"`
}

func (q *Queries) ListFailedJobRuns(ctx context.Context, arg ListFailedJobRunsParams) ([]JobRun, error) {
	rows, err := q.db.QueryContext(ctx, ListFailedJobRuns, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobRun{}
	for rows.Next() {
		var i JobRun
		if err := rows.Scan(
			&i.ID,
			&i.JobName,
			&i.Status,
			&i.Payload,
			&i.Result,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRecentJobRuns = `-- name: ListRecentJobRuns :many
SELECT id, job_name, status, payload, result, error, started_at, completed_at, created_at, updated_at
FROM job_runs
WHERE job_name = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListRecentJobRunsParams struct {
	JobName string `db:"job_name" json:"job_name"`
	Limit   int32  `db:"limit" json:"limit"`
}

func (q *Queries) ListRecentJobRuns(ctx context.Context, arg ListRecentJobRunsParams) ([]JobRun, error) {
	rows, err := q.db.QueryContext(ctx, ListRecentJobRuns, arg.JobName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobRun{}
	for rows.Next() {
		var i JobRun
		if err := rows.Scan(
			&i.ID,
			&i.JobName,
			&i.Status,
			&i.Payload,
			&i.Result,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateJobRunStatus = `-- name: UpdateJobRunStatus :exec
UPDATE job_runs
SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateJobRunStatusParams struct {
	ID     uuid.UUID     `db:"id" json:"id"`
	Status NullJobStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateJobRunStatus(ctx context.Context, arg UpdateJobRunStatusParams) error {
	_, err := q.db.ExecContext(ctx, UpdateJobRunStatus, arg.ID, arg.Status)
	return err
}
